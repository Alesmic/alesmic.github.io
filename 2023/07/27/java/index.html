<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java学习--B站韩顺平 | 木槿汐 | Blog</title><meta name="author" content="alesmic"><meta name="copyright" content="alesmic"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="¶Java （P433…） ¶四种访问修饰符和各自的访问权限    1 本类 同包 子类 不同类     public √ √ √ √   protected √ √ √ ×   默认 √ √ × ×   private √ × × ×    ¶类、属性、方法、局部变量  对象：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。 类：">
<meta property="og:type" content="article">
<meta property="og:title" content="Java学习--B站韩顺平">
<meta property="og:url" content="https://alesmicb.online/2023/07/27/java/index.html">
<meta property="og:site_name" content="木槿汐 | Blog">
<meta property="og:description" content="¶Java （P433…） ¶四种访问修饰符和各自的访问权限    1 本类 同包 子类 不同类     public √ √ √ √   protected √ √ √ ×   默认 √ √ × ×   private √ × × ×    ¶类、属性、方法、局部变量  对象：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。 类：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/java-logo-2048x1280.jpg">
<meta property="article:published_time" content="2023-07-27T06:58:02.000Z">
<meta property="article:modified_time" content="2023-09-08T01:19:24.122Z">
<meta property="article:author" content="alesmic">
<meta property="article:tag" content="Typora">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/java-logo-2048x1280.jpg"><link rel="shortcut icon" href="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/head_ico.png"><link rel="canonical" href="https://alesmicb.online/2023/07/27/java/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/themes/font.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"距离上次更新已经","messageNext":"天了，文章的内容可能已过时。"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java学习--B站韩顺平',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-08 09:19:24'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/themes/font.css"><meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/head.jpg" onerror="onerror=null;src='https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/wallhaven-n625q4_1600x900.png'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 水平</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/java-logo-2048x1280.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="木槿汐 | Blog"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/head_ico.png"/><span class="site-name">木槿汐 | Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 水平</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java学习--B站韩顺平</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-27T06:58:02.000Z" title="发表于 2023-07-27 14:58:02">2023-07-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-08T01:19:24.122Z" title="更新于 2023-09-08 09:19:24">2023-09-08</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java学习--B站韩顺平"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Java-（P433…）"><a class="header-anchor" href="#Java-（P433…）">¶</a>Java （P433…）</h1>
<h1 id="四种访问修饰符和各自的访问权限"><a class="header-anchor" href="#四种访问修饰符和各自的访问权限">¶</a>四种访问修饰符和各自的访问权限</h1>
<table>
<thead>
<tr>
<th>1</th>
<th>本类</th>
<th>同包</th>
<th>子类</th>
<th>不同类</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>默认</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>private</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody>
</table>
<h1 id="类、属性、方法、局部变量"><a class="header-anchor" href="#类、属性、方法、局部变量">¶</a>类、属性、方法、局部变量</h1>
<ul>
<li><strong>对象</strong>：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</li>
<li><strong>类</strong>：类是一个模板，它描述一类对象的行为和状态。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230702152942116.png" alt="image-20230702152942116"></p>
<p>创建一个Car类（Class），它的颜色、品牌、型号是对象（Object）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/20210105-java-object-1.png" alt="img"></p>
<p><strong>方法</strong>可以比作类的行为，eat(),run(),sleep(),name()…</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230702154002023-1688283605440-3.png" alt="image-20230702154002023"></p>
<p>成员变量：表示类方法中外的变量 (蓝色框中的变量 int i = 0…)</p>
<p>局部变量：表示方法中的变量	（红色框中的变量 String name…）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230702154655305.png" alt="image-20230702154655305"></p>
<h3 id="Super方法的注意事项"><a class="header-anchor" href="#Super方法的注意事项">¶</a>Super方法的注意事项</h3>
<ol>
<li>
<p>super调用父类的构造方法，必须在构造方法的第一个.</p>
</li>
<li>
<p>super必须只能出现在子类的方法或者构造方法中.</p>
</li>
<li>
<p>super和this不能同时调用构造方法</p>
</li>
</ol>
<p><strong>Vs this:</strong></p>
<ul>
<li>​	代表的对象不同：</li>
</ul>
<p>​			this：本身调用者这个对象<br>
​			super：代表父类对象的应用</p>
<ul>
<li>​	前提:</li>
</ul>
<p>​			this：没哟继承也可以使用<br>
​			super：只能在继承条件才可以使用</p>
<ul>
<li>​	构造方法:</li>
</ul>
<p>​			this()：本类的构造<br>
​			super()：父类的构造！</p>
<h3 id="方法的重写"><a class="header-anchor" href="#方法的重写">¶</a>方法的重写</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230502115713484.png" alt="image-20230502115713484"></p>
<p>需要有继承关系，子类重写父类的方法！</p>
<ol>
<li>方法名必须相同</li>
<li>参数列表必须相同</li>
<li>修饰符：范围可以扩大，但不能缩小：		public &gt; protected &gt;default</li>
<li>抛出的异常：范围，可以被缩小，但不能扩大：Class Not Found Exception --&gt; Exception(大)</li>
</ol>
<p>==重写，子类的方法和父类必须要一致：方法体不同！==</p>
<p><strong>为什么要重写：</strong></p>
<ol>
<li>父类的功能，子类不一定需要，或者不一定满足！</li>
</ol>
<p>​	<em>Alt + Insert ：override；</em></p>
<h3 id="多态"><a class="header-anchor" href="#多态">¶</a>多态</h3>
<hr>
<p><strong>多态是同一个行为具有多个不同表现形式或形态的能力。</strong></p>
<ol>
<li>多态是方法的多态，属性是没有多态的</li>
<li>父类和子类，有联系 类型转换异常！ClassCastException！</li>
<li>存在类型：继承关系，方法需要重写，父类引用指向子类对象！<em>Father f1 = new Son();</em></li>
</ol>
<p><strong>以下情况不可用多态</strong></p>
<ul>
<li>​	<em>static</em>	方法，属于类，它不属于实例</li>
<li>​	<em>final</em>	常量</li>
<li>​	<em>private</em>	方法</li>
</ul>
<h3 id="static关键字"><a class="header-anchor" href="#static关键字">¶</a>static关键字</h3>
<ul>
<li>静态变量</li>
</ul>
<p>#静态变量在类加载的时候初始化，不需要创建对象，内存就开辟了</p>
<p>#静态变量储存在方法区内存当中</p>
<ul>
<li>静态代码块</li>
</ul>
<p>#语法格式</p>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/download.png" alt="download"></p>
<p>#语法规则</p>
<p>**静态代码块在类加载的时候执行，并且只执行一次，==最早执行==，比main方法都早</p>
<p>***执行顺序：***静态 &gt; 匿名 &gt; 构造</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 第2输出</span></span><br><span class="line">{</span><br><span class="line">    System.out.println(<span class="string">"匿名代码块"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 第3输出</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">bank</span><span class="params">()</span>{</span><br><span class="line">    System.out.println(<span class="string">"构造方法"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 第1输出</span></span><br><span class="line"><span class="keyword">static</span> {</span><br><span class="line">    System.out.println(<span class="string">"静态代码块"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="抽象类"><a class="header-anchor" href="#抽象类">¶</a>抽象类</h3>
<p><strong>什么是抽象类？</strong><br>
父类知道子类一定要完成某个功能，但是每个子类完成的情况是不一样的。子类以后也只会用自己重写的功能，那么父类的功能就可以定义为抽象方法，子类重写调用子类自己的就可以了。这个父类就成为抽象类。</p>
<p>**抽象方法：**没有方法体，只有方法签名，必须用abstract修饰。<br>
拥有抽象方法的类必须定义成抽象类。</p>
<p>==abstract	抽象类==</p>
<ol>
<li>不能new这个抽象类，只能靠子类去实现它：约束</li>
<li>抽象类中可以写普通方法</li>
<li>抽象方法必须在抽象类中</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="comment">//一个类继承了抽象类，必须重写完抽象类的所有抽象方法，否则该类只能定义为抽象类。</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Employees</span>{</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employees</span>{</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> {</span><br><span class="line">		System.out.println(<span class="string">"班主任要管理学生~~"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">Employees</span>{</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> {</span><br><span class="line">		System.out.println(<span class="string">"老师要教育学生~~"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">//测试类：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractDemo</span> {</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">		<span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">		teacher.work();</span><br><span class="line">		</span><br><span class="line">		<span class="type">Manager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>();</span><br><span class="line">		manager.work();</span><br><span class="line">	} </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54070103/article/details/124046117?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168372133616800215074688%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168372133616800215074688&amp;biz_id=0&amp;spm=1018.2226.3001.4187">写下这个</a></p>
<h1 id="类变量-class-variable"><a class="header-anchor" href="#类变量-class-variable">¶</a>类变量(class variable)</h1>
<h2 id="1-案例理解"><a class="header-anchor" href="#1-案例理解">¶</a>1.案例理解</h2>
<p>1.在main方法中定义一个变量count<br>
2.当一个小孩加入游戏后count++,最后个count就记录有多少小孩玩游戏</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">a</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Child</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">"小明"</span>);</span><br><span class="line">        c1.join();</span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">        <span class="type">Child</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">"小李"</span>);</span><br><span class="line">        c2.join();</span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">        <span class="type">Child</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">"小天"</span>);</span><br><span class="line">        c3.join();</span><br><span class="line">        count++;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Child</span> <span class="variable">c4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">"小雪"</span>);</span><br><span class="line">        c4.join();</span><br><span class="line">        count++;</span><br><span class="line">        System.out.println(<span class="string">"共有"</span> + count + <span class="string">"个小孩加入"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> {</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Child</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> {</span><br><span class="line">		System.out.println(name + <span class="string">"加入了游戏..."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>❓问题分析：<br>
1.count是一个独立于对象，很尴尬<br>
2.以后我们访问count很麻烦，没有使用到OOP<br>
3.因此，我们引出类变量/静态变量</p>
<p>如果，设计一个int count表示总人数，我们在创建一个小孩时，就把count加1，并且count是==所有对像共享的就ok==了,我们使用类变量来解决ChildGame.java改进</p>
<p>将变量对所有对象共享</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">a</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Child</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">"小明"</span>);</span><br><span class="line">        c1.join();</span><br><span class="line"><span class="comment">//        count++;</span></span><br><span class="line">        c1.count++;</span><br><span class="line"></span><br><span class="line">        <span class="type">Child</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">"小李"</span>);</span><br><span class="line">        c2.join();</span><br><span class="line"><span class="comment">//        count++;</span></span><br><span class="line">        c2.count++;</span><br><span class="line"></span><br><span class="line">        <span class="type">Child</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">"小天"</span>);</span><br><span class="line">        c3.join();</span><br><span class="line"><span class="comment">//        count++;</span></span><br><span class="line">        c3.count++;</span><br><span class="line"></span><br><span class="line">        <span class="type">Child</span> <span class="variable">c4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">"小雪"</span>);</span><br><span class="line">        c4.join();</span><br><span class="line"><span class="comment">//        count++;</span></span><br><span class="line">        c4.count++;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"共有"</span> + Child.count + <span class="string">"个小孩加入"</span>);</span><br><span class="line">        <span class="comment">//  因为 Child 类共享count自增输出最终结果</span></span><br><span class="line">        System.out.println(c1.count);<span class="comment">// 4</span></span><br><span class="line">        System.out.println(c2.count);<span class="comment">// 4</span></span><br><span class="line">        System.out.println(c3.count);<span class="comment">// 4</span></span><br><span class="line">        System.out.println(c4.count);<span class="comment">// 4</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> {</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"><span class="comment">//定义一个变量 count,是一个类变量(静态变量)static 静态</span></span><br><span class="line"><span class="comment">//该对象最大的特点是会被Child 类的所有的对象实例共享</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Child</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(name + <span class="string">"加入了游戏..."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="概念"><a class="header-anchor" href="#概念">¶</a>概念</h2>
<ul>
<li>什么是类变量</li>
</ul>
<p>类变量也叫<strong>静态变量/静态属性</strong>，是该类的<strong>所有对象共享</strong>的变量，任何一个该类的对象去访问它时，取到的都是相同的值，同样任何一个该类的对象去修改它时，修改的也是同一个变量。这个从前面的图也可看出来。</p>
<ul>
<li>定义语法：</li>
</ul>
<p><code>访问修饰符</code> <code>static</code> <code>数据类型</code> <code>变量名</code>：[推荐]<br>
<code>static</code> <code>访问修饰符``数据类型</code> <code>变量名</code>；</p>
<ul>
<li>如何访问</li>
</ul>
<p><code>类名</code> <code>.</code> <code>类变量名</code>;	[推荐]</p>
<p><code>对象名</code> <code>.</code> <code>类变量名</code>;</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">b</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">      System.out.println(C.name);</span><br><span class="line"></span><br><span class="line">      <span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">      System.out.println(c.name);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> {</span><br><span class="line">    <span class="comment">// 类变量</span></span><br><span class="line"><span class="comment">//    static public String name = "小明";</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">"小明"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="类方法"><a class="header-anchor" href="#类方法">¶</a>类方法</h2>
<p>类方法经典的使用场景<br>
当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率。</p>
<p>比如：工具类中的方法utis<br>
Math类、Arrays类、Collections集合类看下源码：</p>
<p>在程序员实际开发，往往会将一些通用的方法，设计成静态方法，这样我们不需要创建对象就可以使用<br>
了，比如打印一维数组，冒泡排序，完成谋个计算任务等.[举例说明]</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> n1 , <span class="type">int</span> )</span> {</span><br><span class="line">		<span class="keyword">return</span> n1 + n2;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">c</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        D.hi();</span><br><span class="line">        D.say();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> {<span class="comment">//非静态方法，普通方法</span></span><br><span class="line"><span class="comment">//        类方法中不允许使用和对象有关的关键字</span></span><br><span class="line"><span class="comment">//        比如this和super</span></span><br><span class="line">        System.out.println(<span class="string">"ohhhhh"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> {<span class="comment">//静态方法，类方法</span></span><br><span class="line"><span class="comment">//        类方法(静态方法)中 只能访问 静态变量 或静态方法</span></span><br><span class="line">        System.out.println(<span class="string">"hi!!!"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>🫠<strong>小结</strong>：静态方法，只能访问<code>静态的成员</code>，非静态的方法，可以访问<code>静态成员</code>和<code>非静态成员</code></p>
<h1 id="代码块"><a class="header-anchor" href="#代码块">¶</a>代码块</h1>
<h2 id="1-基本介绍"><a class="header-anchor" href="#1-基本介绍">¶</a>1.基本介绍</h2>
<p>代码化块又称为初始化块，属于类中的成员[即是类的一部分]，类似于方法，将逻辑语句封装在方法体中，通过{}包围起来。但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显式调用，而是加载类时，或创建对象时隐式调用。</p>
<h2 id="2-代码块的好处和案例演示"><a class="header-anchor" href="#2-代码块的好处和案例演示">¶</a>2.代码块的好处和案例演示</h2>
<p>1)相当于另外一种形式的构造器（对构造器的补充机制），可以做初始化的操作<br>
2)场景：如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的重用性</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">code01</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Movie</span> <span class="variable">movie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Movie</span>(<span class="string">"闪电侠"</span>);</span><br><span class="line">        <span class="type">Movie</span> <span class="variable">movie1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Movie</span>(<span class="string">"唐人街探案"</span> , <span class="number">100</span> , <span class="string">"陈思诚"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Movie</span> {</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line">    <span class="keyword">private</span> String director;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="comment">//(1)下面的三个构造器都有相同的语句</span></span><br><span class="line">    <span class="comment">//(2)这样代码看起来比较冗余</span></span><br><span class="line">    <span class="comment">//(3)这时我们可以把相同的语句，放入到一个代码块中，即可</span></span><br><span class="line">    <span class="comment">//(4)这样当我们不管调用哪个构造器,创建对象,都会先调用代码块的内容</span></span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line">        System.out.println(<span class="string">"电影屏幕打开.."</span>);</span><br><span class="line">        System.out.println(<span class="string">"广告开始.·."</span>);</span><br><span class="line">        System.out.println(<span class="string">"电影正是开始.."</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Movie</span><span class="params">(String name)</span> {</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        System.out.println("电影屏幕打开..");</span></span><br><span class="line"><span class="comment">        System.out.println("广告开始.·.");</span></span><br><span class="line"><span class="comment">        System.out.println("电影正是开始..");</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Movie</span><span class="params">(String name, <span class="type">double</span> price)</span> {</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        System.out.println("电影屏幕打开..");</span></span><br><span class="line"><span class="comment">        System.out.println("广告开始.·.");</span></span><br><span class="line"><span class="comment">        System.out.println("电影正是开始..");</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Movie</span><span class="params">(String name, <span class="type">double</span> price, String director)</span> {</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        System.out.println("电影屏幕打开..");</span></span><br><span class="line"><span class="comment">        System.out.println("广告开始.·.");</span></span><br><span class="line"><span class="comment">        System.out.println("电影正是开始..");</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">        <span class="built_in">this</span>.director = director;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="3-静态代码块"><a class="header-anchor" href="#3-静态代码块">¶</a>3.静态代码块</h2>
<p>static代码块也叫<code>静态代码块</code>，作用就是对类进行初始化，而且它随着<code>类的加载</code>而执行，并且<br>
只会执行一次。如果是普通代码块，每创建一个对象，就执行。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>类什么时候被加载[重要]👍</p>
<ol>
<li>创建对象实例时(new)</li>
<li>创建子类对象实例，父类也会被加载</li>
<li>使用类的静态成员时（静态属性，静态方法）</li>
<li>普通的代码块，在创建对象实例时，会被隐式的调用。<br>
被==创建==一次，就会==调用==一次。</li>
<li>如果只是使用类的静态成员时，普通代码块并不会执行</li>
</ol>
<p>案例演示：A类extends B类的静态块</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 1.创建对象实例时(new)</span></span><br><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line">    System.out.println(<span class="string">"AAAAAAAAAAAAA"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//输出 AAAAAAAAAAAAAAAAA</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 2.创建子类对象实例，父类也会被加载</span></span><br><span class="line"><span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line">     <span class="keyword">static</span> {</span><br><span class="line">        System.out.println(<span class="string">"AAAAAAAAAAAAA"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> {</span><br><span class="line">     <span class="keyword">static</span> {</span><br><span class="line">        System.out.println(<span class="string">"BBBBBBBBBBBBBBB"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">AAAAAAAAAAAAA</span></span><br><span class="line"><span class="comment">BBBBBBBBBBBBBBB</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>
<p>若父类此时为非静态代码块，则优先输出<code>子类</code></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 如果只是使用类的静态成员时，普通代码块并不会执行</span></span><br><span class="line"></span><br><span class="line">System.out.println(B.t);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line">      {</span><br><span class="line">        System.out.println(<span class="string">"AAAAAAAAAAAAA"</span>);</span><br><span class="line">      } <span class="comment">// 普通代码块不会执行</span></span><br><span class="line">      <span class="keyword">static</span> {</span><br><span class="line">          System.out.println(<span class="string">"A的静态代码块"</span>);</span><br><span class="line">      }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">8888</span>;</span><br><span class="line">    {</span><br><span class="line">        System.out.println(<span class="string">"B的普通代码块"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"111111111111"</span>);</span><br><span class="line">    }</span><br><span class="line">     <span class="keyword">static</span>  {</span><br><span class="line">        System.out.println(<span class="string">"BBBBBBBBBBBBBBB"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*输出</span></span><br><span class="line"><span class="comment">A的静态代码块</span></span><br><span class="line"><span class="comment">BBBBBBBBBBBBBBB</span></span><br><span class="line"><span class="comment">8888</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="4-代码块的调用⭐"><a class="header-anchor" href="#4-代码块的调用⭐">¶</a>4.代码块的调用⭐</h2>
<p>4)创建一个对象时，在一个类<strong>调用顺序</strong>是：（重点，难点）：</p>
<ol>
<li>调用静态代码块和静态属性初始化（注意：静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用)[举例说明]</li>
<li>调用普通代码块和蔷通属性的初始化（注意：普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按定义顺序调用)</li>
<li>调用构造方法。</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> codeBlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">code04</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">V</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">S</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">S</span><span class="params">()</span>{</span><br><span class="line">        System.out.println(<span class="string">"S的无参构造器"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">V</span> <span class="keyword">extends</span> <span class="title class_">S</span>{</span><br><span class="line">    {</span><br><span class="line">        System.out.println(<span class="string">"V的普通代码块"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">V</span><span class="params">()</span>{</span><br><span class="line">        System.out.println(<span class="string">"V的无参构造器"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">S的无参构造器</span></span><br><span class="line"><span class="comment">V的普通代码块</span></span><br><span class="line"><span class="comment">V的无参构造器</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>
<p>🤯<strong>父类静态-&gt;子类静态-&gt;父类普通-&gt;父类构造器-&gt;子类普通-&gt;子类构造器</strong>🤯==[面试题]==</p>
<h1 id="抽象类（abstract）"><a class="header-anchor" href="#抽象类（abstract）">¶</a>抽象类（abstract）</h1>
<ul>
<li>所谓抽象方法就是没有实现的方法</li>
<li>所谓没有实现就是指，没有方法体</li>
<li>当一个类中存在抽象方法时，需要将该类声明为abstract类</li>
<li>一般来说，抽象类会被继承，有其子类来实现抽象方法</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> {</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里eat 实现了，其实没有什么意义</span></span><br><span class="line">    <span class="comment">// 即： 父类方法不确定的问题</span></span><br><span class="line">    <span class="comment">// 将该方法设计为抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>使用场景更多应用于 <code>设计模式</code></p>
<ul>
<li>抽象类不能被实例化[举例]</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">A</span>(); <span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span>() { <span class="comment">//抽象类</span></span><br><span class="line">	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>抽象类不一定要包含abstract方法。也就是说，抽象类可以没有abstract方法[举例]</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> {</span><br><span class="line">		System.out.print(<span class="string">"hi"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>abstract只能修饰类和方法，不能修饰属性和其它的</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span>() {</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="variable">ni</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 报错</span></span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//抽象类的本质还是类，所以可以有类的各种成员</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">D</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">"小红"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"hi"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">ok</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"ok"</span>);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<p>如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract类</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">E</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">F</span> <span class="keyword">extends</span> <span class="title class_">E</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> { <span class="comment">//这里相等于G子类实现了父类E的抽象方法，所谓实现方法，就是有方法体</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//抽象方法不能使用private、final和static来修饰，因为这些关键字都是和重写相违背的</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">H</span> {</span><br><span class="line"><span class="comment">//    private abstract void hi();</span></span><br><span class="line"><span class="comment">//    public final abstract int n = 100;</span></span><br><span class="line"><span class="comment">//    public static abstract void hi();</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><em><strong>继承时，只有父类需要是抽象，子类无需标记abstract，否则main类对象无法实例化</strong></em></p>
<h1 id="设计模式"><a class="header-anchor" href="#设计模式">¶</a>设计模式</h1>
<p><em>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案</em></p>
<p>总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。当然，我们还会讨论另一类设计模式：J2EE 设计模式。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230713173936793.png" alt="image-20230713173936793"></p>
<h2 id="1-单例模式"><a class="header-anchor" href="#1-单例模式">¶</a>1.单例模式</h2>
<p>所谓类的<em><strong>单例设计模式</strong></em>，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法</p>
<p>单例模式分为两种：</p>
<ul>
<li>饿汉式</li>
<li>懒汉式</li>
</ul>
<h3 id="饿汉式"><a class="header-anchor" href="#饿汉式">¶</a>饿汉式</h3>
<p>步骤如下：</p>
<ol>
<li>构造器私有化=》防止直接new</li>
<li>类的内部创建对象</li>
<li>向外暴露一个静态的公共方法getInstance。</li>
<li>代码实现</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hungry</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"><span class="comment">//        GirlFriend xh = new GirlFriend("小红");</span></span><br><span class="line"><span class="comment">//        GirlFriend xb = new GirlFriend("小白");</span></span><br><span class="line">        <span class="type">GirlFriend</span> <span class="variable">gf</span> <span class="operator">=</span> GirlFriend.getInstance();</span><br><span class="line">        System.out.println(gf);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 有一个类</span></span><br><span class="line"><span class="comment">// 只能有一个女朋友</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GirlFriend</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">GirlFriend</span> <span class="variable">gf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GirlFriend</span>(<span class="string">"小"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 构造器私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">GirlFriend</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"><span class="comment">//向外暴露一个静态的公共方法getInstance</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GirlFriend <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> gf;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"GirlFriend{"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="接口"><a class="header-anchor" href="#接口">¶</a>接口</h1>
<h2 id="1-基本概念"><a class="header-anchor" href="#1-基本概念">¶</a>1.基本概念</h2>
<ul>
<li>普通类：只有具体实现</li>
<li>抽象类：具体实现和规范（抽象方法）都有！</li>
<li>接口：只有规范！自己无法写方法专业的约束！约束和实现分离：面向接口编程~</li>
</ul>
<p><code>interface</code>定义的关键字，接口都需要右实现类</p>
<p>==注意：==</p>
<ol>
<li>接口不能被实例化</li>
<li>接口中的所有定义的方法其实都是抽象的<code>public abstract</code>,故不需要写<code>abstract</code>,即可表示抽象类</li>
<li>一个普通类实现接口，就必须将该接口的所有方法都实现</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span>  <span class="title class_">A</span> {		<span class="comment">//用interface定义</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String name)</span>;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">delate</span><span class="params">(String name)</span>;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String name)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">A</span> {	<span class="comment">//再用implements实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String name)</span> {</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delate</span><span class="params">(String name)</span> {</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String name)</span> {</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="2-快速入门"><a class="header-anchor" href="#2-快速入门">¶</a>2.快速入门</h2>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//  ========1========</span></span><br><span class="line"><span class="comment">//	建立一个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">USB</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//	========2========</span></span><br><span class="line"><span class="comment">//	电脑类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">(USB phone)</span>{		<span class="comment">//电脑通过接口连接手机</span></span><br><span class="line">        phone.start();</span><br><span class="line">        phone.stop();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work2</span><span class="params">(USB camera)</span>{		<span class="comment">//电脑通过接口连接相机</span></span><br><span class="line">        camera.start();</span><br><span class="line">        camera.stop();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//	========3========</span></span><br><span class="line"><span class="comment">//	手机类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> <span class="keyword">implements</span> <span class="title class_">USB</span>{				<span class="comment">//手机连接接口</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"手机开始工作"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"手机停止工作"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//  ========4========</span></span><br><span class="line"><span class="comment">//	相机类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Camera</span> <span class="keyword">implements</span> <span class="title class_">USB</span>{				<span class="comment">//相机连接接口</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"相机开始工作"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"相机停止工作"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//	========5========</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"><span class="comment">//        创建相机类 和 手机类</span></span><br><span class="line">        <span class="type">Camera</span> <span class="variable">camera</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Camera</span>();</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line"><span class="comment">//        创建电脑类 ，用相机 和 手机连接电脑</span></span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        System.out.println(<span class="string">"========"</span>);</span><br><span class="line">        computer.work(phone);		</span><br><span class="line">        computer.work2(camera);		</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="3-接口的使用细节"><a class="header-anchor" href="#3-接口的使用细节">¶</a>3.接口的使用细节</h2>
<p>实现方法的快捷键 <code>Ctrl + I</code> 来解决</p>
<ul>
<li>抽象类实现接口,可以不用实现接口的方法</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">B</span> {				<span class="comment">// 报错,因为普通类实现接口要,将方法实现</span></span><br><span class="line">	</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ======================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">B</span> {		<span class="comment">// 抽象类实现接口,可以不用实现接口的方法</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>一个接口不能继承其他类,但是可以继承多个别的接口</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">B</span>,C,D{}</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">B</span>,C,D{}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>接口中的属性,只能是final,而且是 ==public static final== 修饰符</li>
</ul>
<h2 id="接口-VS-继承"><a class="header-anchor" href="#接口-VS-继承">¶</a>接口 VS 继承</h2>
<p>接口相当于是继承的<strong>补充</strong>和<strong>多继承</strong></p>
<blockquote>
<ul>
<li>接口和继承解决的问题不同</li>
<li>继承的价值主要在于：解决代码的<strong>复用性</strong>和<strong>可维护性</strong>。</li>
<li>接口的价值主要在手：设计，设计好各种规范（方法），让其它类去实现这些方法。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>接口比继承更加灵活</li>
<li>接口比继承更加灵活，继承是满足is-a的关系，而接口只需满足ke-a的关系</li>
<li>接口在一定程度上实现代码解耦[即：接口规范性+动态绑定机制]</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">duotai</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        Usb_[] usbs = <span class="keyword">new</span> <span class="title class_">Usb_</span>[<span class="number">2</span>];</span><br><span class="line">        usbs[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">iPhone</span>();</span><br><span class="line">        usbs[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Com</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; usbs.length; i++) {</span><br><span class="line">            usbs[i].work_();</span><br><span class="line">            <span class="keyword">if</span> (usbs[i] <span class="keyword">instanceof</span> iPhone) {</span><br><span class="line">                ((iPhone) usbs[i]).call();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Usb_</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">work_</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">iPhone</span> <span class="keyword">implements</span> <span class="title class_">Usb_</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work_</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"工作中"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"打电话"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Com</span> <span class="keyword">implements</span> <span class="title class_">Usb_</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work_</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"拍照"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="重载（OverLoad）"><a class="header-anchor" href="#重载（OverLoad）">¶</a>重载（OverLoad）</h1>
<p>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</p>
<ul>
<li>被重载的方法必须改变参数列表(参数个数或类型不一样)；</li>
<li>被重载的方法可以改变返回类型；</li>
<li>被重载的方法可以改变访问修饰符；</li>
<li>被重载的方法可以声明新的或更广的检查异常；</li>
<li>方法能够在同一个类中或者在一个子类中被重载。</li>
<li>无法以返回值类型作为重载函数的区分标准。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230705134253254-1688535777146-1.png" alt="image-20230705134253254"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230705134342431.png" alt="image-20230705134342431"></p>
<h1 id="作用域（Scope）"><a class="header-anchor" href="#作用域（Scope）">¶</a>作用域（Scope）</h1>
<p>面向对象中，变量作用域是非常重要知识点，相对来说不是特别好理解</p>
<p>1.在java编程中，主要的变量就是属性（成员变量）和局部变量。<br>
2.我们说的局部变量一般是指在成员方法中定义的变量。【举例Cat类：cry】<br>
3.java中作用域的分类<br>
全局变量：也就是属性，作用域为整个类体Cat类：cry eat等方法使用属性【举例】<br>
局部变量：也就是除了属性之外的其他变量，作用域为定义它的代码块中！<br>
4.<strong>全局变量（属性）可以不赋值</strong>，直接使用，因为有默认值，<strong>局部变量必须赋值后</strong>，才能使用，因为没有默认值。[举例]</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Scope</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> {</span><br><span class="line">    <span class="comment">//全局变量：也就是属性，作用域为整个类体Cat类：cry eat等方法使用属性</span></span><br><span class="line">    <span class="comment">//属性在定义时，可以直接赋值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> {</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1·局部变量一般是指在成员方法中定义的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.n和name就是局部变量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.n和name的作用域在cry方法中</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">"jake"</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>{</span><br><span class="line">        System.out.println(age);<span class="comment">// 用的是全局变量的,可以使用</span></span><br><span class="line"><span class="comment">//      System.out.println(name); 用的是say()方法中的局部变量,不可使用</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Scope</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Person_1</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person_1</span>();</span><br><span class="line">        p1.say();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person_1</span> {</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">"jack"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">//属性和局部变量可以重名，访问时遵循就近原则</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">"king"</span>;</span><br><span class="line">        System.out.println(<span class="string">"say() name="</span> + name);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="构造器"><a class="header-anchor" href="#构造器">¶</a>构造器</h1>
<p>我们来看一个需求：前面我们在创建人类的对象时，是先把一个对象创建好后，再给他的年龄和姓名属性赋值，如果现在我要求，在创建人类的对象时，就直接指定这个对象的年龄和姓名，该怎么做？这时就可以使用构造器。</p>
<p><strong>基本介绍</strong><br>
构造方法又叫==构造器(constructor)==,是类的一种特殊的方法，<br>
它的主要作用是<br>
完成对新对象的初始化。它有几个特点：</p>
<ol>
<li>方法名和类名相同</li>
<li>没有返回值</li>
<li>在创建对象时，系统会自动的调用该类的构造器完成对象的初始化。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">//无参构造器</span><br><span class="line">public A() {}</span><br><span class="line"></span><br><span class="line">//构造器</span><br><span class="line">public A(String n1 ,int n2) {}</span><br></pre></td></tr></tbody></table></figure>
<p>==注意==：</p>
<p>1)构造器的修饰符可以默认，也可以是public protected private<br>
2)构造器没有返回值<br>
3)方法名和类名字必须一样<br>
4)参数列表和成员方法一样的规则<br>
5)构造器的调用，由系统完成</p>
<h1 id="HashCode方法"><a class="header-anchor" href="#HashCode方法">¶</a>HashCode方法</h1>
<p>1)提高具有哈希结构的容器的效率！<br>
2)两个引用，如果指向的是同一个对象，则哈希值肯定是一样的！<br>
3)两个引用，如果指向的是不同对象，则哈希值是不一样的<br>
4)哈希值主要根据地址号来的！，不能完全将哈希值等价于地址。<br>
5)案例演示[HashCode_java]:obj.hashCode(0[测试：Aobj1=new A():Aobj2=newA0;A<br>
obj3 obj1]<br>
6)后面在集合，中hashCode如果需要的话，也会重写</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230624111341058.png" alt="image-20230624111341058"></p>
<h1 id="toString方法"><a class="header-anchor" href="#toString方法">¶</a>toString方法</h1>
<p><strong>基本介绍</strong><br>
默认返回：全类名+@+哈希值的十六进制，【查看Object的toString.方法】<br>
子类往往重写toString方法，用于返回对象的属性信息</p>
<p>//重写tostring方法，输出对象的属性<br>
//使用快捷键即可alt+insert-&gt;toString</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">	<span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hasCode());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">System.out.print(d); <span class="comment">//等价 d.toString()</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="内部类"><a class="header-anchor" href="#内部类">¶</a>内部类</h1>
<hr>
<p>一个类的内部又完整的嵌套了另一个类结构。披嵌套的类称归内部类（inner class)嵌套其他类的类称为外部类(outer cl5S)。是我们类的第五大成员【思考：类的五大成员是哪些[]】，内部黄最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系。</p>
<p>类的五大成员：</p>
<ul>
<li>属性</li>
<li>方法</li>
<li>代码块</li>
<li>构造器</li>
<li>内部类</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> {		<span class="comment">//外部类</span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">inner</span>{}	<span class="comment">//内部类</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">outer</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>  <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;	<span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Outer</span><span class="params">(<span class="type">int</span> n1)</span> {	<span class="comment">//构造器</span></span><br><span class="line">        <span class="built_in">this</span>.n1 = n1;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> {      <span class="comment">//方法</span></span><br><span class="line">        System.out.println(<span class="string">"mi()"</span>);</span><br><span class="line">    }</span><br><span class="line">    {                       <span class="comment">//代码块</span></span><br><span class="line">        System.out.println(<span class="string">"代码块..."</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> {           <span class="comment">//内部类</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>🤷‍♂️定义在外部类局部位置上（比如方法内）：<br>
1)局部内部类（有类名）<br>
2)匿名内部类（没有类名，重点！！！）<br>
🤷‍♀️定义在外部类的成员位置上：<br>
1)成员内部类（没用static修饰）<br>
2)静态内部类（使用static修饰）</p>
<h2 id="局部内部类"><a class="header-anchor" href="#局部内部类">¶</a>局部内部类</h2>
<ol>
<li>局部内部类是定义在外部类的局部位置，通常在方法</li>
<li>可以直接访问外部类的所有成员，包括私有的</li>
<li>不能添加访问修饰符，但是可以使用final修饰</li>
<li>作用域：仅仅在定义它的==方法==或==代码块==中</li>
<li>局部内部类可以直接访问外部类的成员，比如下面外部类1和m2()</li>
<li>如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，</li>
</ol>
<hr>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">jubu</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">outer</span>();</span><br><span class="line">        outer.m1();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">outer</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Outer m2()"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> {	<span class="comment">//方法</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Inner02</span> { 	<span class="comment">//局部内部类</span></span><br><span class="line">            <span class="comment">// 2.可以直接访问外部类的所有成员，包括私有的</span></span><br><span class="line">            <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> {</span><br><span class="line">                System.out.println(<span class="string">"n="</span> + n + <span class="string">"外部类n1"</span> +  outer.<span class="built_in">this</span>.n); <span class="comment">//重名</span></span><br><span class="line">                m2();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Inner02</span> <span class="variable">inner02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner02</span>();</span><br><span class="line">        inner02.f1();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="匿名内部类"><a class="header-anchor" href="#匿名内部类">¶</a>匿名内部类</h2>
<p>本质还是类	内部类	这个类没有名字	同时还是一个对象</p>
<ol>
<li>外部其他类–不能访问–一&gt;匿名内部类（因为匿名内部类地位是一个局部变量）</li>
<li>如果外部类和匿名内部类的成员重名时，匿名内部类访问的话，默认遵循就近原则<br>
如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Anonymous</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Outer02</span> <span class="variable">outer02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer02</span>();</span><br><span class="line">        outer02.method();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer02</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>{   <span class="comment">//方法</span></span><br><span class="line">        <span class="comment">//基于接口的匿名内部类</span></span><br><span class="line">        <span class="comment">//1.需求：想使用IA接口，并创建对象</span></span><br><span class="line">        <span class="comment">//2,传统方式，是写一个类，实现该接口，并创建对象</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">tiger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> {</span><br><span class="line">                System.out.println(<span class="string">"老虎"</span>);</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">        tiger.cry();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        A tiger = new Tiger();</span></span><br><span class="line"><span class="comment">//        tiger.cry();</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> {   <span class="comment">//接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//class Tiger implements A {      //传统方法</span></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public void cry() {</span></span><br><span class="line"><span class="comment">//        System.out.println("qqqqqqqqq");</span></span><br><span class="line"><span class="comment">//    }</span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//class Dog implements A {</span></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public void cry() {</span></span><br><span class="line"><span class="comment">//        System.out.println("ppppppppppp");</span></span><br><span class="line"><span class="comment">//    }</span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> {  <span class="comment">//类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">(String name)</span> {    <span class="comment">//构造器</span></span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> {      <span class="comment">//方法</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="使用细节"><a class="header-anchor" href="#使用细节">¶</a>使用细节</h3>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Anonymous02</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">X</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">X</span>();</span><br><span class="line">        x.fi();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">99</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fi</span><span class="params">()</span> { <span class="comment">//方法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 内部类在方法中使用</span></span><br><span class="line">        <span class="comment">// 创建一个基于类的匿名内部类</span></span><br><span class="line">        <span class="comment">// 匿名内部类两种使用方法</span></span><br><span class="line">        <span class="comment">// 1.new一个类，随后调用😉</span></span><br><span class="line">        <span class="type">Z</span> <span class="variable">z</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Z</span>(<span class="string">"jack"</span>) {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> {</span><br><span class="line">                <span class="built_in">super</span>.hi();</span><br><span class="line">                System.out.println(i);<span class="comment">//返回10</span></span><br><span class="line">                System.out.println(X.<span class="built_in">this</span>.i);<span class="comment">//返回99</span></span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">        z.hi();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2.直接当对象使用🤯</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Z</span>(<span class="string">"pipi"</span>) {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> {</span><br><span class="line">                <span class="built_in">super</span>.hi();</span><br><span class="line">            }</span><br><span class="line">        }.hi();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Z</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Z</span><span class="params">(String name)</span> {</span><br><span class="line">        System.out.println(<span class="string">"bbbbbbbbbb"</span> + name);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"hi"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="成员内部类"><a class="header-anchor" href="#成员内部类">¶</a>成员内部类</h2>
<p>成员内部类是定义在外部类的成员位置，并且没有static修饰</p>
<p>成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。<strong>创建成员内部类</strong>对象的一般方式如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  {</span><br><span class="line">        <span class="comment">//第一种方式：</span></span><br><span class="line">        <span class="type">Outter</span> <span class="variable">outter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outter</span>();</span><br><span class="line">        Outter.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outter.<span class="keyword">new</span> <span class="title class_">Inner</span>();  <span class="comment">//必须通过Outter对象来创建</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//第二种方式：</span></span><br><span class="line">        Outter.<span class="type">Inner</span> <span class="variable">inner1</span> <span class="operator">=</span> outter.getInnerInstance();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outter</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Outter</span><span class="params">()</span> {</span><br><span class="line">         </span><br><span class="line">    }</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInnerInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span>(inner == <span class="literal">null</span>)</span><br><span class="line">            inner = <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        <span class="keyword">return</span> inner;</span><br><span class="line">    }</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> {</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Inner</span><span class="params">()</span> {</span><br><span class="line">             </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>成员内部类–访问–&gt;外部类（比如：属性)[]（说明）</li>
<li>外部类–访问–&gt;成员内部类（说明）访问方式：创建对象，再访问</li>
<li>外部其他类–访问–&gt;成员内部类</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemberInner</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        b.tic();</span><br><span class="line"></span><br><span class="line">        B.<span class="type">BI</span> <span class="variable">bi</span> <span class="operator">=</span> b.<span class="keyword">new</span> <span class="title class_">BI</span>();</span><br><span class="line">        System.out.println(bi.t);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BI</span> {<span class="comment">// 成员内部类</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> {</span><br><span class="line"><span class="comment">//          成员内部类--访问--&gt;外部类(访问方式：直接访问)</span></span><br><span class="line">            System.out.println(i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tic</span><span class="params">()</span> {</span><br><span class="line"><span class="comment">//      外部类--访问--&gt;成员内部类（说明）访问方式：创建对象，再访问</span></span><br><span class="line"><span class="comment">//        BI bi = new BI();</span></span><br><span class="line"><span class="comment">//        bi.say();</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="静态内部类"><a class="header-anchor" href="#静态内部类">¶</a>静态内部类</h2>
<p>说明：静态内部类是定义在外部类的成员位置，并且有static修饰</p>
<ol>
<li>可以<strong>直接访问</strong>外部类的<strong>所有</strong>静态成员，包含私有的，但不能直接访问非静态成员</li>
<li>可以添加任意访问修饰符(public、protected、默认、private),因为它的地位就是一个成员。</li>
<li>作用域：同其他的成员，为整个类体</li>
<li>如果外部类和静态内部类的成员重名时，静态内部类访问的时，默认遵循就近原则，如果想访问外部类的成员，则可以使用(外部类成员)去访问</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">staticInner</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Outer01</span> <span class="variable">outer01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer01</span>();</span><br><span class="line">        outer01.tic();</span><br><span class="line">        </span><br><span class="line">        Outer01.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer01</span>.Inner();</span><br><span class="line">        System.out.println(inner.i);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer01</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">"张三"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span> {</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> {</span><br><span class="line"><span class="comment">//      4.静态内部类--访问--&gt;外部类（比如：静态属性)[访问方式：直接访问所有静 态成员]</span></span><br><span class="line"></span><br><span class="line">            System.out.println(name);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tic</span><span class="params">()</span> {</span><br><span class="line"><span class="comment">//      5.外部类--访问---&gt;静态内部类访问方式：创建对象，再访问</span></span><br><span class="line">        <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        System.out.println(inner.i);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="枚举类（Enum）"><a class="header-anchor" href="#枚举类（Enum）">¶</a>枚举类（Enum）</h1>
<p>Java 枚举是一个特殊的类，一般表示一组常量，比如一年的 4 个季节，一年的 12 个月份，一个星期的 7 天，方向有东南西北等。将一个一个具体的类列出来。</p>
<p>Java 枚举类使用 enum 关键字来定义，各个常量使用逗号 <strong>,</strong> 来分割。</p>
<h2 id="自定义类实现枚举"><a class="header-anchor" href="#自定义类实现枚举">¶</a>自定义类实现枚举</h2>
<ul>
<li>不需要提供setXxx方法，因为枚举对象值通常为只读</li>
<li>对枚举对象/属性使用final+static共同修饰，实现底层优化.</li>
<li>枚举对象名通常使用全部大写，常量的命名规范</li>
<li>枚举对象根据需要，也可以有多个属性</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> enumclass;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @author 徐永豪</span></span><br><span class="line"><span class="comment"> * @version 1.0</span></span><br><span class="line"><span class="comment"> * 2023/7/23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">code01</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(Season.AUTUMN);</span><br><span class="line">        System.out.println(Season.WINTER);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 自定义枚举类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span> {</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"><span class="comment">// 3.在Season的内部,直接创建固定的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">"冬天"</span>,<span class="string">"寒冷"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">"春天"</span>,<span class="string">"温暖"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">"夏天"</span>,<span class="string">"炎热"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">"秋天"</span>,<span class="string">"凉爽"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">OTHER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">"白天"</span>,<span class="string">"明亮"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  1.将构造器私有化,目的防止直接new</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name, String desc)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.删去set方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Season{"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", desc='"</span> + desc + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果使用了enum来实现枚举类</p>
<ol>
<li>使用关键字enum替代class</li>
<li>public static final Season SPRING=new Season(“春天”，“温暖”)直接使用SPRING(“春天”，"温暖、解读常量名（实参列表）</li>
<li>如果有多个常量（对象），使用，号间隔即可</li>
<li>如果使用enum来实现枚举，要求将定义常量对象，写在前面</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Season02</span> {</span><br><span class="line">    WINTER(<span class="string">"冬天"</span>,<span class="string">"寒冷"</span>),SPRING(<span class="string">"春天"</span>,<span class="string">"温暖"</span>),</span><br><span class="line">    SUMMER(<span class="string">"夏天"</span>,<span class="string">"炎热"</span>),AUTUMN(<span class="string">"秋天"</span>,<span class="string">"凉爽"</span>),</span><br><span class="line">    OTHER(<span class="string">"白天"</span>,<span class="string">"明亮"</span>);</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">    <span class="comment">// 3.在Season的内部,直接创建固定的对象</span></span><br><span class="line"><span class="comment">//    public static final Season WINTER = new Season("冬天","寒冷");</span></span><br><span class="line"><span class="comment">//    public static final Season SPRING = new Season("春天","温暖");</span></span><br><span class="line"><span class="comment">//    public static final Season SUMMER = new Season("夏天","炎热");</span></span><br><span class="line"><span class="comment">//    public static final Season AUTUMN = new Season("秋天","凉爽");</span></span><br><span class="line"><span class="comment">//    public static final Season OTHER = new Season("白天","明亮");</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  1.将构造器私有化,目的防止直接new</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season02</span><span class="params">(String name, String desc)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.删去set方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Season02{"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", desc='"</span> + desc + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="enum常用方法"><a class="header-anchor" href="#enum常用方法">¶</a>enum常用方法</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230726135853880-1690351152039-1.png" alt="image-20230726135853880"></p>
<p>还有一个<em><strong>values方法</strong></em>，可以将<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%9E%9A%E4%B8%BE%E7%B1%BB&amp;spm=1001.2101.3001.7020">枚举类</a>转变为一个枚举类型的数组，因为枚举中没有下标，我们没有办法通过下标来快速找到需要的枚举类，这时候，转变为数组之后，我们就可以通过数组的下标，来找到我们需要的枚举类</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">code03</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Season02</span> <span class="variable">autumn</span> <span class="operator">=</span> Season02.AUTUMN;</span><br><span class="line"><span class="comment">//      输出枚举对象的名字</span></span><br><span class="line">        System.out.println(autumn.name());</span><br><span class="line"><span class="comment">//      ordinal()输出的是该枚举对象的次序/编号，从0开始编号</span></span><br><span class="line"><span class="comment">//      AUTUMN枚举对象是第三个，因此输出2</span></span><br><span class="line">        System.out.println(autumn.ordinal());</span><br><span class="line"><span class="comment">//        Season[] values = Season02.values();</span></span><br><span class="line"><span class="comment">//        for (Season02 season : values) {</span></span><br><span class="line"><span class="comment">//            //增强for循环</span></span><br><span class="line"><span class="comment">//        }</span></span><br><span class="line">        <span class="type">int</span>[] nums = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">9</span>};</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">            System.out.print(nums[i] + <span class="string">"\t"</span>);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"=======增强for======="</span>);</span><br><span class="line"><span class="comment">//      执行流程是依次从nums数组中取出数据，赋给i，如果取出完毕，则退出for</span></span><br><span class="line"><span class="comment">//      for (int i : nums)</span></span><br><span class="line">        <span class="keyword">for</span>(Season02 season02 : Season02.values()) {</span><br><span class="line">            System.out.println(season02);</span><br><span class="line">        }</span><br><span class="line"><span class="comment">//      value0f:将字符串转换成枚举对象，要求字符串必须VT为已有的常量名，否则报异常</span></span><br><span class="line">        <span class="type">Season02</span> <span class="variable">aut</span> <span class="operator">=</span> Season02.valueOf(<span class="string">"AUTUMN"</span>);</span><br><span class="line">        System.out.println(<span class="string">"AUT"</span> + aut);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="案例"><a class="header-anchor" href="#案例">¶</a>案例</h2>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1)声明Week枚举类，其中包含星期一至星期日的定义；</span></span><br><span class="line"><span class="comment">MONDAY TUESDAY,WEDNESDAY,THURSDAY,</span></span><br><span class="line"><span class="comment">FRIDAY,SATURDAY,SUNDAY;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2)使用values返回所有的枚举数组，并遍历，输出左图</span></span><br><span class="line"><span class="comment">===所有星期的信息如下==</span></span><br><span class="line"><span class="comment">    星期一</span></span><br><span class="line"><span class="comment">    星期二</span></span><br><span class="line"><span class="comment">    星期三</span></span><br><span class="line"><span class="comment">    星期四</span></span><br><span class="line"><span class="comment">    星期五</span></span><br><span class="line"><span class="comment">    星期六</span></span><br><span class="line"><span class="comment">    星期日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">exercise</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        Week[] value = Week.values();</span><br><span class="line">        System.out.println(<span class="string">"===所有星期的信息如下=="</span>);</span><br><span class="line">        <span class="keyword">for</span> (Week week : value) {</span><br><span class="line">            System.out.println(week);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Week</span> {</span><br><span class="line">    MONDAY(<span class="string">"星期一"</span>),TUESDAY(<span class="string">"星期二"</span>),WEDNESDAY(<span class="string">"星期三"</span>),</span><br><span class="line">    THURSDAY(<span class="string">"星期四"</span>), FRIDAY(<span class="string">"星期五"</span>),SATURDAY(<span class="string">"星期六"</span>),SUNDAY(<span class="string">"星期日"</span>);</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Week</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="JDK中基本的三种注解"><a class="header-anchor" href="#JDK中基本的三种注解">¶</a>JDK中基本的三种注解</h1>
<ul>
<li>1)注解(Annotation)也被称为元数据(Metadata),用于修饰解释包、类、方法、属性、构造器、局部变量等数据信息。</li>
<li>2)和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息。</li>
<li>3)在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEEr中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替java EE旧版中所遗留的繁冗代码和XML配置等。</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.runoob.com/wp-content/uploads/2019/08/28124653-adf73c4cdcce4a63b7bf78efbe1a9cdf.jpg" alt="img" style="zoom: 80%;">
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230905164339036.png" alt="image-20230905164339036"></p>
<h2 id="Override"><a class="header-anchor" href="#Override">¶</a>@Override</h2>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Override_</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Father</span> <span class="variable">father</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Father</span>();</span><br><span class="line">        <span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        father.fly();</span><br><span class="line">        son.fly();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>{</span><br><span class="line">        System.out.println(<span class="string">"Father fly&gt;&gt;&gt;"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>{</span><br><span class="line">    <span class="meta">@Override</span>   <span class="comment">// 此出若不写也可表示重写，编译器会去检测以下方法是否表示重写，</span></span><br><span class="line">    <span class="comment">//但若是写了Override，编译器会对此进行检验，若是不符合重写，会报错</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>{</span><br><span class="line">        System.out.println(<span class="string">"Son fly&gt;&gt;&gt;"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Deprecated"><a class="header-anchor" href="#Deprecated">¶</a>@Deprecated</h2>
<ol>
<li>@Deprecated 修饰某个元素，表示该元素已经过时</li>
<li>即不在推荐使用，但仍然可以使用</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230905170744760.png" alt="image-20230905170744760"></p>
<h2 id="SuppressWarnings"><a class="header-anchor" href="#SuppressWarnings">¶</a>@SuppressWarnings</h2>
<ol>
<li>当我们不希望看到这些警告的时候，可以使用 @SuppressWarnings 注解来抑制警告信息</li>
<li>在{“”}中,可以写入你希望抑制(不显示)警告信息</li>
</ol>
<blockquote>
<ol>
<li>“all”：抑制所有警告。 说明：使用该属性可以忽略所有警告，但这种做法有潜在风险，可能会导致代码出现潜在的问题，所以建议只在特殊情况下使用。</li>
<li>“unchecked”：抑制类型转换检查的警告。 说明：Java编译器在进行类型转换时会发出警告，使用该属性可以忽略这些警告。</li>
<li>“deprecation”：抑制使用过时方法或类的警告。 说明：当我们使用某个已被标记为过时的方法或类时，编译器会发出警告。使用该属性可以忽略这些警告。</li>
<li>“rawtypes”：抑制使用原始类型（raw type）的警告。 说明：当我们使用未经参数化的泛型类型时，编译器会发出警告。使用该属性可以忽略这些警告。</li>
<li>“unchecked, rawtypes”：同时抑制类型转换检查和使用原始类型的警告。 说明：使用该属性可以同时忽略类型转换检查和使用原始类型的警告。</li>
</ol>
</blockquote>
<h1 id="异常"><a class="header-anchor" href="#异常">¶</a>异常</h1>
<h4 id="1、什么是异常，java提供异常处理机制有什么用？"><a class="header-anchor" href="#1、什么是异常，java提供异常处理机制有什么用？">¶</a>1、什么是异常，java提供异常处理机制有什么用？</h4>
<ul>
<li>什么是异常：程序执行过程中的<strong>不正常</strong>情况。</li>
<li>异常的作用：增强程序的 <strong><code>健壮性</code></strong>。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest01</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 实际上JVM在执行到此处的时候，会new异常对象：new ArithmeticException("/ by zero");</span></span><br><span class="line">        <span class="comment">// 并且JVM将new的异常对象抛出，打印输出信息到控制台了。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a / b;</span><br><span class="line">        System.out.println(a + <span class="string">"/"</span> + b + <span class="string">"="</span> + c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此处运行也会创建一个：ArithmeticException类型的异常对象。</span></span><br><span class="line">        System.out.println(<span class="number">100</span> / <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="2、java语言中异常是以什么形式存在的呢？"><a class="header-anchor" href="#2、java语言中异常是以什么形式存在的呢？">¶</a>2、java语言中异常是以什么形式存在的呢？</h4>
<p>异常在java中以 <strong><code>类</code></strong> 的形式存在，每一个 <em><strong>异常类</strong></em> 都可以创建 <em><strong>异常对象</strong></em>。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest02</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 通过“异常类”实例化“异常对象”</span></span><br><span class="line">        <span class="type">NumberFormatException</span> <span class="variable">nfe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumberFormatException</span>(<span class="string">"数字格式化异常！"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// java.lang.NumberFormatException: 数字格式化异常！</span></span><br><span class="line">        System.out.println(nfe);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="3、异常继承结构图"><a class="header-anchor" href="#3、异常继承结构图">¶</a>3、异常继承结构图</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzE1OTQz%2Csize_16%2Ccolor_FFFFFF%2Ct_70.png" alt="在这里插入图片描述"></p>
<ul>
<li>
<p>Exception的直接子类：<strong>编译时异常</strong>（要求程序员在编写程序阶段必须预先对这些异常进行处理，如果不处理编译器报错，因此得名编译时异常。）。</p>
</li>
<li>
<p>RuntimeException：<strong>运行时异常</strong>。（在编写程序阶段程序员可以预先处理，也可以不管，都行。）</p>
</li>
</ul>
<h4 id="4、异常的分类"><a class="header-anchor" href="#4、异常的分类">¶</a>4、异常的分类</h4>
<p>异常分为 <strong><code>编译时异常</code></strong> 和 <strong><code>运行时异常</code></strong>。</p>
<p>所有异常都是在 <strong><code>运行阶段</code></strong> 发生的。因为只有程序运行阶段才可以 <strong>new</strong>对象。</p>
<p>因为异常的发生就是 <strong><code>new异常对象</code></strong>。</p>
<h5 id="4-1编译时异常因为什么而得名？"><a class="header-anchor" href="#4-1编译时异常因为什么而得名？">¶</a>4.1编译时异常因为什么而得名？</h5>
<p>因为编译时异常必须在编译(编写)阶段预先处理，如果不处理编译器报错，因此得名。</p>
<h5 id="4-2-编译时异常和运行时异常的区别？"><a class="header-anchor" href="#4-2-编译时异常和运行时异常的区别？">¶</a>4.2 编译时异常和运行时异常的区别？</h5>
<ul>
<li>
<p>编译时异常一般发生的概率 <strong><code>比较高</code></strong>。</p>
</li>
<li>
<p>运行时异常一般发生的概率 <strong><code>比较低</code></strong>。</p>
</li>
<li>
<p>编译时异常发生概率较高，需要在运行之前对其进行 <strong><code>预处理</code></strong>。</p>
</li>
<li>
<p>运行时异常发生概率较低，<strong>没必要</strong>提前进行预处理。</p>
</li>
</ul>
<h5 id="4-3编译时异常和运行时异常别称"><a class="header-anchor" href="#4-3编译时异常和运行时异常别称">¶</a>4.3编译时异常和运行时异常别称</h5>
<ul>
<li>编译时异常</li>
</ul>
<ol>
<li><strong>受检</strong>异常：CheckedException</li>
<li><strong>受控</strong>异常</li>
</ol>
<ul>
<li>运行时异常</li>
</ul>
<ol>
<li><strong>未受检</strong>异常：UnCheckedException</li>
<li><strong>非受控</strong>异常</li>
</ol>
<h4 id="5、异常的处理方式"><a class="header-anchor" href="#5、异常的处理方式">¶</a>5、异常的处理方式</h4>
<h5 id="5-1-throws"><a class="header-anchor" href="#5-1-throws">¶</a>5.1 throws</h5>
<p>在方法声明的位置上使用 <strong><code>throws</code></strong> <strong>关键字</strong>抛出，谁调用我这个方法，我就抛给谁。抛给 <strong><code>调用者</code></strong> 来处理。</p>
<p>这种处理异常的态度：<strong>上报</strong>。</p>
<h5 id="5-2-try…catch"><a class="header-anchor" href="#5-2-try…catch">¶</a>5.2 try…catch</h5>
<p><strong>注意：</strong></p>
<ul>
<li>只要异常没有捕捉，采用<strong>上报</strong>的方式，此方法的 <strong><code>后续代码不会执行</code></strong>。</li>
<li><strong>try语句块</strong>中的某一行出现异常，该行 <strong><code>后面的代码不会执行</code></strong>。</li>
<li>try…catch<strong>捕捉异常之后</strong>，后续代码可以执行。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException {</span><br><span class="line">    System.out.println(<span class="string">"m1 begin"</span>);</span><br><span class="line">    m2();</span><br><span class="line">    <span class="comment">// 以上代码出异常，这里是无法执行的。</span></span><br><span class="line">    System.out.println(<span class="string">"m1 over"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    m1();</span><br><span class="line">    <span class="comment">// m1方法出异常，下面代码不执行。</span></span><br><span class="line">    System.out.println(<span class="string">"hello world!"</span>);<span class="comment">//不执行</span></span><br><span class="line">} <span class="keyword">catch</span> (FileNotFoundException e){ </span><br><span class="line">	<span class="comment">//异常处理</span></span><br><span class="line">    System.out.println(<span class="string">"出异常了！！"</span>);</span><br><span class="line">    System.out.println(e); </span><br><span class="line">}</span><br><span class="line">System.out.println(<span class="string">"hello world"</span>); <span class="comment">//会执行</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> {</span><br><span class="line">	<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"D:\\Download\\Javabean-addperson案例解析.docx"</span>);</span><br><span class="line">} <span class="keyword">catch</span>(FileNotFoundException e) {</span><br><span class="line">	System.out.println(<span class="string">"文件不存在！"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">等同于</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">	<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"D:\\Download\\Javabean-addperson案例解析.docx"</span>);</span><br><span class="line">} <span class="keyword">catch</span>(Exception e) {<span class="comment">// 多态：Exception e = new FileNotFoundException();</span></span><br><span class="line">	System.out.println(<span class="string">"文件不存在！"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"D:\\Download\\Javabean-addperson案例解析.docx"</span>);</span><br><span class="line">    fis.read();</span><br><span class="line">} <span class="keyword">catch</span>(IOException e){</span><br><span class="line">    System.out.println(<span class="string">"读文件报错了！"</span>);</span><br><span class="line">} <span class="keyword">catch</span>(FileNotFoundException e) {</span><br><span class="line">    System.out.println(<span class="string">"文件不存在！"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="8、异常两个重要方法"><a class="header-anchor" href="#8、异常两个重要方法">¶</a>8、异常两个重要方法</h4>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>String getMessage()</td>
<td>返回异常的详细消息字符串</td>
</tr>
<tr>
<td>void printStackTrace()</td>
<td>追踪堆栈异常信息(采用异步线程)</td>
</tr>
</tbody>
</table>
<h4 id="9、finally字句"><a class="header-anchor" href="#9、finally字句">¶</a>9、finally字句</h4>
<p>在finally子句中的代码是最后执行的，并且是 <strong><code>一定会执行</code></strong> 的，即使try语句块中的代码出现了异常。</p>
<p><strong>finally</strong>子句必须和<strong>try</strong>一起出现，不能单独编写。</p>
<h5 id="9-1-finally语句通常使用在哪些情况下呢？"><a class="header-anchor" href="#9-1-finally语句通常使用在哪些情况下呢？">¶</a>9.1 finally语句通常使用在哪些情况下呢？</h5>
<p>通常在finally语句块中完成 <strong><code>资源的释放/关闭</code></strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230514212441058.png" alt="image-20230514212441058"></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest10</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 声明位置放到try外面。这样在finally中才能用。</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"D:\\Download\\Javabean-addperson案例解析.docx"</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 这里一定会出现空指针异常！</span></span><br><span class="line">            s.toString();</span><br><span class="line">            System.out.println(<span class="string">"hello world!"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 流使用完需要关闭，因为流是占用资源的。</span></span><br><span class="line">            <span class="comment">// 即使以上程序出现异常，流也必须要关闭！</span></span><br><span class="line">            <span class="comment">// 放在这里有可能流关不了。</span></span><br><span class="line">            <span class="comment">//fis.close();</span></span><br><span class="line">        } <span class="keyword">catch</span> (FileNotFoundException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">catch</span>(IOException e){</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">catch</span>(NullPointerException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            System.out.println(<span class="string">"hello 浩克！"</span>);</span><br><span class="line">            <span class="comment">// 流的关闭放在这里比较保险。</span></span><br><span class="line">            <span class="comment">// finally中的代码是一定会执行的。</span></span><br><span class="line">            <span class="comment">// 即使try中出现了异常！</span></span><br><span class="line">            <span class="keyword">if</span> (fis != <span class="literal">null</span>) { <span class="comment">// 避免空指针异常！</span></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="comment">// close()方法有异常，采用捕捉的方式。</span></span><br><span class="line">                    fis.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="9-2try和finally联用，没有catch"><a class="header-anchor" href="#9-2try和finally联用，没有catch">¶</a>9.2try和finally联用，没有catch</h5>
<p><strong>以下代码的执行顺序：</strong></p>
<ol>
<li>先执行try…</li>
<li>再执行finally…</li>
<li>最后执行 return （return语句只要执行方法必然结束。）</li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li>try不能单独使用。</li>
<li>try finally可以联合使用。</li>
<li>放在finally语句块中的代码是一定会执行的</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest11</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    	<span class="keyword">try</span> {</span><br><span class="line">            System.out.println(<span class="string">"try..."</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            System.out.println(<span class="string">"finally..."</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里不能写语句，因为这个代码是无法执行到的。</span></span><br><span class="line">        <span class="comment">//System.out.println("Hello World!");</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="9-3-finally子句失效"><a class="header-anchor" href="#9-3-finally子句失效">¶</a>9.3 finally子句失效</h5>
<p><strong><code>System.exit(0);</code></strong> 只有这个可以治finally。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest12</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(<span class="string">"try..."</span>);</span><br><span class="line">            <span class="comment">// 退出JVM</span></span><br><span class="line">            System.exit(<span class="number">0</span>); <span class="comment">// 退出JVM之后，finally语句中的代码就不执行了！</span></span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            System.out.println(<span class="string">"finally..."</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="9-5-final-finally-finalize有什么区别？"><a class="header-anchor" href="#9-5-final-finally-finalize有什么区别？">¶</a>9.5 final finally finalize有什么区别？</h5>
<ul>
<li>final <strong>关键字</strong></li>
</ul>
<ol>
<li>final修饰的<code>类</code><strong>无法继承</strong></li>
<li>final修饰的<code>方法</code><strong>无法覆盖</strong></li>
<li>final修饰的<code>变量</code><strong>不能重新赋值</strong>。</li>
</ol>
<ul>
<li>finally <strong>关键字</strong></li>
</ul>
<ol>
<li>finally 和<strong>try</strong>一起联合使用。</li>
<li>finally语句块中的代码是<strong>必须执行</strong>的。</li>
</ol>
<ul>
<li>finalize <strong>标识符</strong></li>
</ul>
<ol>
<li>是一个Object类中的方法名。</li>
<li>这个方法是由垃圾回收器<strong>GC</strong>负责调用的</li>
</ol>
<h4 id="10、自定义异常（开发中常用）"><a class="header-anchor" href="#10、自定义异常（开发中常用）">¶</a>10、自定义异常（开发中常用）</h4>
<h5 id="10-1前言"><a class="header-anchor" href="#10-1前言">¶</a>10.1前言</h5>
<p>SUN提供的JDK内置的异常肯定是不够的用的。在实际的开发中，有很多业务，这些业务出现异常之后，JDK中都是没有的。和业务挂钩的。因此需要自定义异常。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230906113908532.png" alt="image-20230906113908532" style="zoom:60%;">
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230906113945256.png" alt="image-20230906113945256"></p>
<h5 id="10-2自定义异常步骤"><a class="header-anchor" href="#10-2自定义异常步骤">¶</a>10.2自定义异常步骤</h5>
<ol>
<li>第一步：编写一个类<strong>继承</strong> <strong><code>Exception</code></strong> 或者 <strong><code>RuntimeException</code></strong>.</li>
<li>第二步：提供两个 <strong><code>构造方法</code></strong>，一个<strong>无参数</strong>的，一个<strong>带有String参数</strong>的。</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//栈操作异常：自定义异常！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackOperationException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>{ <span class="comment">// 编译时异常！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStackOperationException</span><span class="params">()</span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStackOperationException</span><span class="params">(String s)</span>{</span><br><span class="line">        <span class="built_in">super</span>(s);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="11、方法覆盖，时遗留的问题"><a class="header-anchor" href="#11、方法覆盖，时遗留的问题">¶</a>11、方法覆盖，时遗留的问题</h4>
<ul>
<li>重写之后的方法不能比重写之前的方法抛出更多（更宽泛）的异常，可以更少。<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44715943/article/details/115680718">方法覆盖</a></li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doOther</span><span class="params">()</span> <span class="keyword">throws</span> Exception{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译正常。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span> <span class="keyword">throws</span> RuntimeException{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译报错。</span></span><br><span class="line">    <span class="comment">/*public void doSome() throws Exception{</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    }*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译正常。</span></span><br><span class="line">    <span class="comment">/*public void doOther() {</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    }*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译正常。</span></span><br><span class="line">    <span class="comment">/*public void doOther() throws Exception{</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    }*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译正常。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doOther</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>注意：</strong><br>
一般不会这样考虑，方法覆盖复制一份，然后重写就好了。</p>
<h4 id="12、总结异常中的关键字"><a class="header-anchor" href="#12、总结异常中的关键字">¶</a>12、总结异常中的关键字</h4>
<ul>
<li>异常捕捉：</li>
</ul>
<ol>
<li><strong>try</strong></li>
<li><strong>catch</strong></li>
<li><strong>finally</strong></li>
</ol>
<ul>
<li><strong>throws</strong> 在方法声明位置上使用，表示<strong>上报异常信息</strong>给<strong>调用者</strong>。</li>
<li><strong>throw</strong> <strong>手动抛出异常</strong>！</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> <span class="keyword">throws</span> StackOperationException {</span><br><span class="line">	<span class="keyword">if</span>(index &lt; <span class="number">0</span>){</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyStackOperationException</span>(<span class="string">"弹栈失败，栈已空！"</span>);<span class="comment">//手动抛出异常</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="包装类（Wrapper）"><a class="header-anchor" href="#包装类（Wrapper）">¶</a>包装类（Wrapper）</h1>
<h2 id="八个包装类的继承关系图"><a class="header-anchor" href="#八个包装类的继承关系图">¶</a>八个包装类的继承关系图</h2>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230906172124317.png" alt="image-20230906172124317" style="zoom:67%;">
<h2 id="包装类方法"><a class="header-anchor" href="#包装类方法">¶</a>包装类方法</h2>
<p>包装类就是把String字符串类型	（int，double，long…）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230906192536744.png" alt="image-20230906192536744"></p>
<h2 id="String"><a class="header-anchor" href="#String">¶</a>String</h2>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">"xyh"</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">"xyh"</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">"ww"</span>;</span><br><span class="line">System.out.println(a == b);	<span class="comment">// T</span></span><br><span class="line">System.out.println(a.equals(b));	<span class="comment">// T</span></span><br><span class="line">System.out.println(a == c);			<span class="comment">// F</span></span><br><span class="line">System.out.println(a.equals(c));	<span class="comment">// F</span></span><br></pre></td></tr></tbody></table></figure>
<p><code>equals</code>可以看作只检查内容，而<code>==</code>是不仅检查内容，还要检查地址</p>
<h2 id="String类常用方法"><a class="header-anchor" href="#String类常用方法">¶</a>String类常用方法</h2>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230907164233737.png" alt="image-20230907164233737" style="zoom:67%;">
<blockquote>
<p>equals/区分大小写，判断内容是否相等<br>
equalslgnoreCase/忽略大小写的判断内容是否相等<br>
length/获取字符的个数，字符串的长度<br>
indexOf/获取字符在字符串中第1次出现的索引，索引从0开始，如果找不到，返回-1<br>
lastIndexOf//获取字符在字符串中最后1次出现的索引，索引从0开始，如找不到，返回-1<br>
substring/截取指定范围的子串<br>
trim/去前后空格<br>
charAt:获取某索引处的字符，注意不能使用Str[index]这种方式.</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WrapperMethed</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">//equals/区分大小写，判断内容是否相等</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="string">"Hello"</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="string">"hello"</span>;</span><br><span class="line">        System.out.println(n1.equals(n2));  <span class="comment">// F</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//equalslgnoreCase/忽略大小写的判断内容是否相等</span></span><br><span class="line">        System.out.println(n1.equalsIgnoreCase(n2));    <span class="comment">// T</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//length/获取字符的个数，字符串的长度</span></span><br><span class="line">        System.out.println(n1.length());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//indexOf/获取字符在字符串中^^第1次^^出现的索引，索引从0开始，如果找不到，返回-1</span></span><br><span class="line">        System.out.println(n1.indexOf(<span class="string">"o"</span>));    <span class="comment">//4,查找字符下标</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//lastIndexOf/获取字符在字符串中^^最后1次^^出现的索引，索引从0开始，如找不到，返回-1</span></span><br><span class="line">        System.out.println(n1.lastIndexOf(<span class="string">"l"</span>));    <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//substring/截取指定范围的子串</span></span><br><span class="line">        System.out.println(n1.substring(<span class="number">2</span>,<span class="number">5</span>));  <span class="comment">//llo</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//trim/去前后空格</span></span><br><span class="line">        <span class="comment">//charAt:获取某索引处的字符，注意不能使用Str[index]这种方式.D</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="String格式化"><a class="header-anchor" href="#String格式化">¶</a>String格式化</h2>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">第一种方式</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.format(<span class="string">"数据转换成各个%s"</span>, n1);</span><br><span class="line"></span><br><span class="line">第二种方式</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">"数据转换成各个%s"</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">info2</span> <span class="operator">=</span> String.format(str2,n2);</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<ul>
<li>//1.%s,%d,%.2f%c称为占位符</li>
<li>//2,这些占位符由后面变量来替换</li>
<li>//3.%s表示后面由字符串来替换</li>
<li>//4,%d是整数来替换</li>
<li>//5,%.2F表示使用小数来替换，替换后，只会保留小数点两位，并且进行四舍五入的处理</li>
<li>/6,%c使用char类型米替换</li>
</ul>
</blockquote>
<h2 id="StringBuffer"><a class="header-anchor" href="#StringBuffer">¶</a>StringBuffer</h2>
<h3 id="和String的区别"><a class="header-anchor" href="#和String的区别">¶</a>和String的区别</h3>
<p>Java中的String和StringBuffer是两种不同的字符串类型，它们有以下几个主要区别：</p>
<ol>
<li>可变性：String是<code>不可变的字符串</code>类型，即一旦创建了一个String对象，它的<code>值就不能被修改</code>。而StringBuffer是<code>可变</code>的字符串类型，可以通过调用其方法来修改字符串的内容。</li>
<li>性能：由于String是不可变的，每次对String对象的操作都会创建一个新的String对象，这会导致频繁的内存分配和回收，对于大量的字符串操作会降低性能。而StringBuffer是可变的，可以在原有对象上直接进行修改，避免了频繁的内存分配和回收，因此在大量字符串拼接的场景下性能更好。</li>
<li>方法支持：由于String不可变，它提供了更多的方法来操作和获取字符串的内容，如substring、length、charAt等。而StringBuffer提供了一些用于修改和操作字符串的方法，如append、insert、delete等。</li>
</ol>
<p><strong>综上所述，String和StringBuffer在可变性、线程安全性、性能和方法支持等方面存在差异。根据具体的需求，选择合适的字符串类型可以充分发挥其优点和功能。<code>当需要频繁地修改字符串时</code>，建议使用StringBuffer；当字符串不需要被修改且在<code>多线程</code>环境下使用时，使用String更为合适。</strong></p>
<h1 id="线程"><a class="header-anchor" href="#线程">¶</a>线程</h1>
<h3 id="一-线程创建"><a class="header-anchor" href="#一-线程创建">¶</a>一.线程创建</h3>
<h3 id="线程基础知识介绍"><a class="header-anchor" href="#线程基础知识介绍">¶</a>线程基础知识介绍</h3>
<p>什么是线程？为什么要使用线程？</p>
<p>​    在没有使用到线程的程序中，我们总是只能串行的执行程序，也就是我们的程序一次性只能进行一个操作。而我们使用微信进行视频聊天的时候，我们可以一边视频，一边和其他人打字聊天。这就是多线程，可以一个线程负责视频聊天，一个线程负责打字聊天，使用的任然是一个程序。在日常使用场景中，多线程是必要的。</p>
<h3 id="创建方法一：继承Thread类"><a class="header-anchor" href="#创建方法一：继承Thread类">¶</a>创建方法一：继承Thread类</h3>
<p>​    Thread单词意思就是线程的意思，是Java提供的一个线程类。可以自己创建一个类然后继承Thread，重写run方法。run方法写入你想要进行多线程运行的代码。</p>
<p>​    通过你建的类，实例化一个对象；通过这个对象调用start()方法，该对象就可以进行多线程操作了。</p>
<p>创建步骤：</p>
<p>​    1.继承Thread类，重写run方法</p>
<p>​    2.实例化一个对象，调用start方法（就是执行run函数里面的内容）</p>
<p>代码演示：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//1 创建两个类，继承Thread，都重写run方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) {</span><br><span class="line">            System.out.println(<span class="string">"Thread1 running!"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) {</span><br><span class="line">            System.out.println(<span class="string">"Thread2 running!"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">//2 对这两个类分别实例化一个对象，调用start方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Thread1</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread1</span>();</span><br><span class="line">        <span class="type">Thread2</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread2</span>();</span><br><span class="line"> </span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>​    运行结果发现，Thread1线程和Thread2线程轮流上处理机执行，由此可知该段程序确实实现了多线程操作</p>
<h3 id="创建方法二：实现Runnable接口"><a class="header-anchor" href="#创建方法二：实现Runnable接口">¶</a>创建方法二：实现Runnable接口</h3>
<p>Runnable是一个接口，该接口是一个函数式接口（不知道函数式接口的伙伴，可以看看我上一篇博客哦），只有一个抽象方法run</p>
<p>创建方法一的Thread类就是实现了Runnable接口，查看源码如下图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230514215608092.png" alt="image-20230514215608092"></p>
<p>​    那为什么已经有Java开发人员已经给我们封装好的Thread类，有更多的方法可以供我们调用，我们还要用Runnable接口来实现线程，不是很冗余嘛，容我卖个关子，会在代码中解释。</p>
<p>创建步骤：</p>
<p>​    1 创建一个类实现Runnable接口，重写run方法</p>
<p>​    2 通过该类实例化对象</p>
<p>​    3 将实例化的对象作为参数传到Thread实现线程，再调用start方法</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//1 创建Demo1实现Runnable接口，重写run方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>{</span><br><span class="line">    <span class="comment">//run方法模拟买票场景</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">//设置票数为10</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 只要票数有剩余，就可以一直进行买票</span></span><br><span class="line">        <span class="keyword">while</span> (ticket &gt; <span class="number">0</span>){</span><br><span class="line">            <span class="comment">// Thread.currentThread()该静态方法可以获得当前运行的线程 getName()得到线程名称</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"   get   "</span> +ticket--);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">//2 实例化一个demo1对象</span></span><br><span class="line">        <span class="type">Demo1</span> <span class="variable">demo1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo1</span>();</span><br><span class="line">        <span class="comment">//3 将实例化的对象作为参数传到Thread实现线程</span></span><br><span class="line">        <span class="comment">//Thread有传入一个对象的构造器，构造器还能加入线程的名称</span></span><br><span class="line">        <span class="comment">//实例化了多个Thread类，再调用start方法，就能实现多个线程对同一个对象进行操作</span></span><br><span class="line">        <span class="comment">//这就是为什么还要用Runnable接口来实现线程的原因</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo1,<span class="string">"pp"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo1,<span class="string">"mc"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo1,<span class="string">"pp1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo1,<span class="string">"mc1"</span>).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面代码用到的构造器：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230514215740525.png" alt="image-20230514215740525"></p>
<h2 id="创建方法三：实现Callable接口；线程池"><a class="header-anchor" href="#创建方法三：实现Callable接口；线程池">¶</a>创建方法三：实现Callable接口；线程池</h2>
<p>​    Callable也是一个接口，可以使用到线程池。当多线程场景下，我们一直创建或者销毁线程，对性能影响都很大，如果我们提前创建好多个线程，放入线程池，使用时直接获取，使用完放回池中，就可以避免一直创建、销毁，达到重复利用。</p>
<h3 id="线程池"><a class="header-anchor" href="#线程池">¶</a>线程池</h3>
<p><strong>ExecutorService</strong>   线程池接口</p>
<p>常用方法：</p>
<ul>
<li>​    void <strong>execute</strong>(Runnable command); 执行任务，没有返回值，一般用来执行<strong>Runnable</strong></li>
<li>​    <t> <strong>Future</strong><t> submit(Callable<t> task);执行任务，有返回值，一般用来执行<strong>Callable</strong></t></t></t></li>
<li>​    void shutdown();关闭连接池</li>
</ul>
<p><strong>Executors</strong> 该类用于创建线程池</p>
<h3 id="Callable接口实现多线程"><a class="header-anchor" href="#Callable接口实现多线程">¶</a>Callable接口实现多线程</h3>
<p>​    实现callable接口需要返回值类型 ，而上述两种方法是不需要返回值的。不同与上述两种方法，实现Callable需要重写call方法，而不是run方法，并且call方法需要抛出异常。</p>
<p>创建步骤：</p>
<p>​    1 创建一个类实现Callable接口，重写call方法</p>
<p>​    2 创建目标对象，即通过该类实例化对象</p>
<p>​    3 创建执行的服务，可通过实现线程池来创建</p>
<p>​    4 提交执行 callable为submit方法</p>
<p>​    5  获取结果</p>
<p>​    6 关闭服务</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*实现callable接口需要返回值类型*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Boolean&gt; {</span><br><span class="line">    <span class="comment">//重写call方法需要抛出异常</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException {</span><br><span class="line">        <span class="comment">//1 创建目标对象</span></span><br><span class="line">        <span class="type">TestCallable</span> <span class="variable">testCallable1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestCallable</span>();</span><br><span class="line">        <span class="type">TestCallable</span> <span class="variable">testCallable2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestCallable</span>();</span><br><span class="line">        <span class="type">TestCallable</span> <span class="variable">testCallable3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestCallable</span>();</span><br><span class="line">        <span class="comment">//2 创建执行的服务</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">ser</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//3 提交执行</span></span><br><span class="line">        Future&lt;Boolean&gt; f1 = ser.submit(testCallable1);</span><br><span class="line">        Future&lt;Boolean&gt; f2 = ser.submit(testCallable2);</span><br><span class="line">        Future&lt;Boolean&gt; f3 = ser.submit(testCallable3);</span><br><span class="line">        <span class="comment">//4 获取结果</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">r1</span> <span class="operator">=</span> f1.get();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">r2</span> <span class="operator">=</span> f2.get();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">r3</span> <span class="operator">=</span> f3.get();</span><br><span class="line">        <span class="comment">//5 关闭服务</span></span><br><span class="line">        ser.shutdown();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>​</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://alesmicb.online">alesmic</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://alesmicb.online/2023/07/27/java/">https://alesmicb.online/2023/07/27/java/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://alesmicb.online" target="_blank">木槿汐 | Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Typora/">Typora</a><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/java-logo-2048x1280.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/wechat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/07/07/html/" title="简单地认识一下 HTML"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/20230729145814.png" onerror="onerror=null;src='https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/wallhaven-n625q4_1600x900.png'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">简单地认识一下 HTML</div></div></a></div><div class="next-post pull-right"><a href="/2023/07/29/typora-jiao-cheng/" title="Markdown"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/20230729150630.png" onerror="onerror=null;src='https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/wallhaven-n625q4_1600x900.png'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Markdown</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/07/29/git-github/" title="Git &amp;&amp; Github"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/20230729150921.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-29</div><div class="title">Git &amp;&amp; Github</div></div></a></div><div><a href="/2023/07/29/docker/" title="Decker"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/20230729151159.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-29</div><div class="title">Decker</div></div></a></div><div><a href="/2023/07/07/html/" title="简单地认识一下 HTML"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/20230729145814.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-07</div><div class="title">简单地认识一下 HTML</div></div></a></div><div><a href="/2023/07/07/javascript/" title="简单地认识一下 JavaScript"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/20230729150111.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-07</div><div class="title">简单地认识一下 JavaScript</div></div></a></div><div><a href="/2023/09/08/mysql/" title="MySQL"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/20230729145814.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-08</div><div class="title">MySQL</div></div></a></div><div><a href="/2023/08/05/python-mang-she-shu-gen-lian/" title="Python蟒蛇书跟练"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/20230805131049.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-05</div><div class="title">Python蟒蛇书跟练</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/head.jpg" onerror="this.onerror=null;this.src='https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/wallhaven-n625q4_1600x900.png'" alt="avatar"/></div><div class="author-info__name">alesmic</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xxxxx" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/3230426733@qq.com" target="_blank" title="QQ"><i class="fa-brands fa-qq" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:xyhyxu@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%EF%BC%88P433%E2%80%A6%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">Java （P433…）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%92%8C%E5%90%84%E8%87%AA%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">2.</span> <span class="toc-text">四种访问修饰符和各自的访问权限</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E3%80%81%E5%B1%9E%E6%80%A7%E3%80%81%E6%96%B9%E6%B3%95%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">3.</span> <span class="toc-text">类、属性、方法、局部变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Super%E6%96%B9%E6%B3%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.0.1.</span> <span class="toc-text">Super方法的注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99"><span class="toc-number">3.0.2.</span> <span class="toc-text">方法的重写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">3.0.3.</span> <span class="toc-text">多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.0.4.</span> <span class="toc-text">static关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">3.0.5.</span> <span class="toc-text">抽象类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F-class-variable"><span class="toc-number">4.</span> <span class="toc-text">类变量(class variable)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A1%88%E4%BE%8B%E7%90%86%E8%A7%A3"><span class="toc-number">4.1.</span> <span class="toc-text">1.案例理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">4.2.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.</span> <span class="toc-text">类方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">5.</span> <span class="toc-text">代码块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">5.1.</span> <span class="toc-text">1.基本介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84%E5%A5%BD%E5%A4%84%E5%92%8C%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA"><span class="toc-number">5.2.</span> <span class="toc-text">2.代码块的好处和案例演示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">5.3.</span> <span class="toc-text">3.静态代码块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84%E8%B0%83%E7%94%A8%E2%AD%90"><span class="toc-number">5.4.</span> <span class="toc-text">4.代码块的调用⭐</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%88abstract%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">抽象类（abstract）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.1.</span> <span class="toc-text">1.单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A5%BF%E6%B1%89%E5%BC%8F"><span class="toc-number">7.1.1.</span> <span class="toc-text">饿汉式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">8.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">8.1.</span> <span class="toc-text">1.基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">8.2.</span> <span class="toc-text">2.快速入门</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82"><span class="toc-number">8.3.</span> <span class="toc-text">3.接口的使用细节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3-VS-%E7%BB%A7%E6%89%BF"><span class="toc-number">8.4.</span> <span class="toc-text">接口 VS 继承</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%EF%BC%88OverLoad%EF%BC%89"><span class="toc-number">9.</span> <span class="toc-text">重载（OverLoad）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%88Scope%EF%BC%89"><span class="toc-number">10.</span> <span class="toc-text">作用域（Scope）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">11.</span> <span class="toc-text">构造器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HashCode%E6%96%B9%E6%B3%95"><span class="toc-number">12.</span> <span class="toc-text">HashCode方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#toString%E6%96%B9%E6%B3%95"><span class="toc-number">13.</span> <span class="toc-text">toString方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">14.</span> <span class="toc-text">内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">14.1.</span> <span class="toc-text">局部内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">14.2.</span> <span class="toc-text">匿名内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82"><span class="toc-number">14.2.1.</span> <span class="toc-text">使用细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">14.3.</span> <span class="toc-text">成员内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">14.4.</span> <span class="toc-text">静态内部类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%EF%BC%88Enum%EF%BC%89"><span class="toc-number">15.</span> <span class="toc-text">枚举类（Enum）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%AE%9E%E7%8E%B0%E6%9E%9A%E4%B8%BE"><span class="toc-number">15.1.</span> <span class="toc-text">自定义类实现枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#enum%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">15.2.</span> <span class="toc-text">enum常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">15.3.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JDK%E4%B8%AD%E5%9F%BA%E6%9C%AC%E7%9A%84%E4%B8%89%E7%A7%8D%E6%B3%A8%E8%A7%A3"><span class="toc-number">16.</span> <span class="toc-text">JDK中基本的三种注解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Override"><span class="toc-number">16.1.</span> <span class="toc-text">@Override</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Deprecated"><span class="toc-number">16.2.</span> <span class="toc-text">@Deprecated</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SuppressWarnings"><span class="toc-number">16.3.</span> <span class="toc-text">@SuppressWarnings</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">17.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%82%E5%B8%B8%EF%BC%8Cjava%E6%8F%90%E4%BE%9B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">17.0.0.1.</span> <span class="toc-text">1、什么是异常，java提供异常处理机制有什么用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81java%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%BC%82%E5%B8%B8%E6%98%AF%E4%BB%A5%E4%BB%80%E4%B9%88%E5%BD%A2%E5%BC%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">17.0.0.2.</span> <span class="toc-text">2、java语言中异常是以什么形式存在的呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%BC%82%E5%B8%B8%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-number">17.0.0.3.</span> <span class="toc-text">3、异常继承结构图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">17.0.0.4.</span> <span class="toc-text">4、异常的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1%E7%BC%96%E8%AF%91%E6%97%B6%E5%BC%82%E5%B8%B8%E5%9B%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E8%80%8C%E5%BE%97%E5%90%8D%EF%BC%9F"><span class="toc-number">17.0.0.4.1.</span> <span class="toc-text">4.1编译时异常因为什么而得名？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-%E7%BC%96%E8%AF%91%E6%97%B6%E5%BC%82%E5%B8%B8%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">17.0.0.4.2.</span> <span class="toc-text">4.2 编译时异常和运行时异常的区别？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3%E7%BC%96%E8%AF%91%E6%97%B6%E5%BC%82%E5%B8%B8%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E5%88%AB%E7%A7%B0"><span class="toc-number">17.0.0.4.3.</span> <span class="toc-text">4.3编译时异常和运行时异常别称</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">17.0.0.5.</span> <span class="toc-text">5、异常的处理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-throws"><span class="toc-number">17.0.0.5.1.</span> <span class="toc-text">5.1 throws</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-try%E2%80%A6catch"><span class="toc-number">17.0.0.5.2.</span> <span class="toc-text">5.2 try…catch</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81%E5%BC%82%E5%B8%B8%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E6%96%B9%E6%B3%95"><span class="toc-number">17.0.0.6.</span> <span class="toc-text">8、异常两个重要方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E3%80%81finally%E5%AD%97%E5%8F%A5"><span class="toc-number">17.0.0.7.</span> <span class="toc-text">9、finally字句</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#9-1-finally%E8%AF%AD%E5%8F%A5%E9%80%9A%E5%B8%B8%E4%BD%BF%E7%94%A8%E5%9C%A8%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8B%E5%91%A2%EF%BC%9F"><span class="toc-number">17.0.0.7.1.</span> <span class="toc-text">9.1 finally语句通常使用在哪些情况下呢？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-2try%E5%92%8Cfinally%E8%81%94%E7%94%A8%EF%BC%8C%E6%B2%A1%E6%9C%89catch"><span class="toc-number">17.0.0.7.2.</span> <span class="toc-text">9.2try和finally联用，没有catch</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-3-finally%E5%AD%90%E5%8F%A5%E5%A4%B1%E6%95%88"><span class="toc-number">17.0.0.7.3.</span> <span class="toc-text">9.3 finally子句失效</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-5-final-finally-finalize%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">17.0.0.7.4.</span> <span class="toc-text">9.5 final finally finalize有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%EF%BC%88%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E7%94%A8%EF%BC%89"><span class="toc-number">17.0.0.8.</span> <span class="toc-text">10、自定义异常（开发中常用）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#10-1%E5%89%8D%E8%A8%80"><span class="toc-number">17.0.0.8.1.</span> <span class="toc-text">10.1前言</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-2%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E6%AD%A5%E9%AA%A4"><span class="toc-number">17.0.0.8.2.</span> <span class="toc-text">10.2自定义异常步骤</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11%E3%80%81%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%EF%BC%8C%E6%97%B6%E9%81%97%E7%95%99%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">17.0.0.9.</span> <span class="toc-text">11、方法覆盖，时遗留的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12%E3%80%81%E6%80%BB%E7%BB%93%E5%BC%82%E5%B8%B8%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">17.0.0.10.</span> <span class="toc-text">12、总结异常中的关键字</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%EF%BC%88Wrapper%EF%BC%89"><span class="toc-number">18.</span> <span class="toc-text">包装类（Wrapper）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E4%B8%AA%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%9B%BE"><span class="toc-number">18.1.</span> <span class="toc-text">八个包装类的继承关系图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">18.2.</span> <span class="toc-text">包装类方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String"><span class="toc-number">18.3.</span> <span class="toc-text">String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">18.4.</span> <span class="toc-text">String类常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-number">18.5.</span> <span class="toc-text">String格式化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringBuffer"><span class="toc-number">18.6.</span> <span class="toc-text">StringBuffer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8CString%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">18.6.1.</span> <span class="toc-text">和String的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">19.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="toc-number">19.0.1.</span> <span class="toc-text">一.线程创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%BB%8B%E7%BB%8D"><span class="toc-number">19.0.2.</span> <span class="toc-text">线程基础知识介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E7%BB%A7%E6%89%BFThread%E7%B1%BB"><span class="toc-number">19.0.3.</span> <span class="toc-text">创建方法一：继承Thread类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="toc-number">19.0.4.</span> <span class="toc-text">创建方法二：实现Runnable接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3%EF%BC%9B%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">19.1.</span> <span class="toc-text">创建方法三：实现Callable接口；线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">19.1.1.</span> <span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Callable%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">19.1.2.</span> <span class="toc-text">Callable接口实现多线程</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/09/08/mysql/" title="MySQL"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/20230729145814.png" onerror="this.onerror=null;this.src='https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/wallhaven-n625q4_1600x900.png'" alt="MySQL"/></a><div class="content"><a class="title" href="/2023/09/08/mysql/" title="MySQL">MySQL</a><time datetime="2023-09-08T02:25:00.000Z" title="发表于 2023-09-08 10:25:00">2023-09-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/28/zheng-ze-biao-da-shi/" title="卢文彬"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/20230808150712.png" onerror="this.onerror=null;this.src='https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/wallhaven-n625q4_1600x900.png'" alt="卢文彬"/></a><div class="content"><a class="title" href="/2023/08/28/zheng-ze-biao-da-shi/" title="卢文彬">卢文彬</a><time datetime="2023-08-28T13:05:00.000Z" title="发表于 2023-08-28 21:05:00">2023-08-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/08/da-jian-tu-chuang-a-li-yun-ban/" title="搭建图床(阿里云)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/20230810150251.png - Typora - aliyun" onerror="this.onerror=null;this.src='https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/wallhaven-n625q4_1600x900.png'" alt="搭建图床(阿里云)"/></a><div class="content"><a class="title" href="/2023/08/08/da-jian-tu-chuang-a-li-yun-ban/" title="搭建图床(阿里云)">搭建图床(阿里云)</a><time datetime="2023-08-08T11:01:00.000Z" title="发表于 2023-08-08 19:01:00">2023-08-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/07/python-pa-chong/" title="Python爬虫"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/20230808150712.png" onerror="this.onerror=null;this.src='https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/wallhaven-n625q4_1600x900.png'" alt="Python爬虫"/></a><div class="content"><a class="title" href="/2023/08/07/python-pa-chong/" title="Python爬虫">Python爬虫</a><time datetime="2023-08-07T07:05:00.000Z" title="发表于 2023-08-07 15:05:00">2023-08-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/05/python-mang-she-shu-gen-lian/" title="Python蟒蛇书跟练"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/20230805131049.png" onerror="this.onerror=null;this.src='https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/wallhaven-n625q4_1600x900.png'" alt="Python蟒蛇书跟练"/></a><div class="content"><a class="title" href="/2023/08/05/python-mang-she-shu-gen-lian/" title="Python蟒蛇书跟练">Python蟒蛇书跟练</a><time datetime="2023-08-05T05:25:00.000Z" title="发表于 2023-08-05 13:25:00">2023-08-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">本网站由<a target="_blank" rel="noopener" href="https://www.upyun.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/%E5%8F%88%E6%8B%8D%E4%BA%91_logo6.png" style="width:3vw;"></a>提供CDN加速</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="4881756305" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true" data-lrcType="-1"> </div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="false"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>