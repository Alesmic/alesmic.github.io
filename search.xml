<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL</title>
      <link href="/2023/09/08/mysql/"/>
      <url>/2023/09/08/mysql/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卢文彬</title>
      <link href="/2023/08/28/zheng-ze-biao-da-shi/"/>
      <url>/2023/08/28/zheng-ze-biao-da-shi/</url>
      
        <content type="html"><![CDATA[<p>111</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建图床(阿里云)</title>
      <link href="/2023/08/08/da-jian-tu-chuang-a-li-yun-ban/"/>
      <url>/2023/08/08/da-jian-tu-chuang-a-li-yun-ban/</url>
      
        <content type="html"><![CDATA[<p><a href="https://so.csdn.net/so/search?q=%E5%9B%BE%E5%BA%8A&amp;spm=1001.2101.3001.7020">图床</a>就是用来存储图片的地方<br>将我们的图片上传到别人的网站，它会给我们一个链接，然后我们可以应用到我们的博客上。<br>有的图床会为我们提供<a href="https://so.csdn.net/so/search?q=API&amp;spm=1001.2101.3001.7020">API</a>接口，通过程序去调用</p><p>因为有些第三方的图床虽然免费但不太稳定,例如Gitee的图床已经被严查,不能使用了</p><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/191e0b882466ec2d53b5da23652b8b2f.png" alt="191e0b882466ec2d53b5da23652b8b2f"></p><p>所以我推荐使用<strong>阿里云的对象存储OSS</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫</title>
      <link href="/2023/08/07/python-pa-chong/"/>
      <url>/2023/08/07/python-pa-chong/</url>
      
        <content type="html"><![CDATA[<h1 id="爬虫第一步：查看robots-txt"><a class="header-anchor" href="#爬虫第一步：查看robots-txt">¶</a>爬虫第一步：查看robots.txt</h1><h2 id="什么是robots-txt"><a class="header-anchor" href="#什么是robots-txt">¶</a>什么是robots.txt</h2><p>robots.txt是网站管理者写给爬虫的一封信，里面描述了网站管理者不希望爬虫做的事，比如：</p><ul><li>不要访问某个文件、文件夹</li><li>禁止某些爬虫的访问</li><li>限制爬虫访问网站的频率</li></ul><p>一个自觉且善意的爬虫，应该在抓取网页之前，先阅读robots.txt，了解并执行网站管理者制定的爬虫规则。</p><h2 id="如何查看robot-txt"><a class="header-anchor" href="#如何查看robot-txt">¶</a>如何查看robot.txt</h2><p>在浏览器的网址搜索栏中，输入网站的根域名，然后再输入/robot.txt。比如，必应的robots.txt网址为</p><blockquote><p><a href="https://link.zhihu.com/?target=https%3A//cn.bing.com/robots.txt">https://cn.bing.com/robots.txt</a></p></blockquote><h2 id="robots-txt的内容"><a class="header-anchor" href="#robots-txt的内容">¶</a>robots.txt的内容</h2><p>User-agent: 爬虫的名称</p><p>Disallow: 不允许爬虫访问的地址</p><p>Allow: 允许爬虫访问的地址</p><p>若User-agent是*，则表示对象是所有爬虫。</p><p>Disallow和Allow后面跟的是地址，地址的描述格式符合正则表达式(regex)的规则。因此可以在python中使用正则表达式来筛选出可以访问的地址。</p><p>下面是来自<a href="https://link.zhihu.com/?target=http%3A//cn.bing.com">http://cn.bing.com</a>的一段robots.txt：</p><figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">User-agent: msnbot-media </span><br><span class="line">Disallow: /</span><br><span class="line">Allow: /th?</span><br><span class="line"></span><br><span class="line">User-agent: Twitterbot</span><br><span class="line">Disallow: </span><br><span class="line"></span><br><span class="line">User-agent: *</span><br><span class="line">Disallow: /account/</span><br><span class="line">Disallow: /amp/</span><br></pre></td></tr></tbody></table></figure><h1 id="安装requests"><a class="header-anchor" href="#安装requests">¶</a>安装requests</h1><p>Python的<code>requests库</code>,让我们可以通过Python代码,去构建和发送HTTP请求,由于<code>requests库</code>是第三方库</p><p>所有先要进行安装</p><ul><li>进入编译器,在终端输入</li></ul><figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></tbody></table></figure><h1 id="Web-http"><a class="header-anchor" href="#Web-http">¶</a>Web / http</h1><ol><li><p>服务器渲染：在服务器那边直接把数据和htmL整合在一起，统一返回给浏览器在页面源代码中能看到数据</p><p>​向服务器提交信息，返回结果，将结果信息嵌入在HTML文件中</p></li><li><p>客户端渲染：第一次请求只要一个html骨架。第二次请求拿到数据.进行数据展示，在面源代码中看不到数据</p></li></ol><p>​相当于在进入网站时，提供了一个框架，进行检索后提供内容</p>]]></content>
      
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python蟒蛇书跟练</title>
      <link href="/2023/08/05/python-mang-she-shu-gen-lian/"/>
      <url>/2023/08/05/python-mang-she-shu-gen-lian/</url>
      
        <content type="html"><![CDATA[<p><a href="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5.pdf">Python编程：从入门到实践.pdf</a> （下载链接）</p><h1 id="第1章-配置环境（略过🤯）"><a class="header-anchor" href="#第1章-配置环境（略过🤯）">¶</a>第1章 配置环境（略过🤯）</h1><h2 id="第2章-变量和简单数据类型"><a class="header-anchor" href="#第2章-变量和简单数据类型">¶</a>第2章 变量和简单数据类型</h2><p>​<img src="Python%E8%9F%92%E8%9B%87%E4%B9%A6%E8%B7%9F%E7%BB%83.assets/image-20230818235422776.png" alt="image-20230818235422776"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git &amp;&amp; Github</title>
      <link href="/2023/07/29/git-github/"/>
      <url>/2023/07/29/git-github/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a class="header-anchor" href="#简介">¶</a>简介</h1><p><strong>git</strong></p><p>​    是一个版本管理工具，是可以在你电脑不联网的情况下，只在本地使用的一个版本管理工具，其作用就是可以让你更好的管理你的程序，比如你原来提交过的内容，以后虽然修改了，但是通过git这个工具，可以把你原来提交的内容重现出来，这样对于你后来才意识到的一些错误的更改，可以进行还原。</p><p>关于github，这是一个网站，就是每个程序员自己写的程序，可以在github上建立一个网上的仓库，你每次提交的时候可以把代码提交到网上，这样你的每次提交，别人也都可以看到你的代码，同时别人也可以帮你修改你的代码，这种开源的方式非常方便程序员之间的交流和学习。</p><p><strong>github</strong></p><p>​是一个非常适合程序员交流的网站，很多国际上的技术大牛都在github上有自己的开源代码，其他人只要申请个账号就可以随意的看到这些大牛写的程序。同时国内的很多互联网公司如百度，阿里等，也在github上公布有开源的代码，感兴趣的程序员也可以自己查找着看一些。</p><p>总结来说，git可以认为是一个软件，能够帮你更好的写程序，github则是一个网站，这个网站可以帮助程序员之间互相交流和学习。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Git </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Decker</title>
      <link href="/2023/07/29/docker/"/>
      <url>/2023/07/29/docker/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker"><a class="header-anchor" href="#Docker">¶</a>Docker</h2><h3 id="DockerFile"><a class="header-anchor" href="#DockerFile">¶</a>DockerFile</h3><p>FROM --指定基础镜像</p><p>RUN --执行命令</p><p>COPY --从上下文目录中选定指定的文件或目录复制到容器指定的路径下</p><p>ADD --和COPY类似，在针对压缩包时会自动解压</p><p>CMD --指定默认的容器主进程</p><p>EXPOSE --暴露端口</p><p>WORKDIR --设置工作目录</p><p>ARG --构建参数和 <code>ENV</code> 的效果一样，都是设置环境变量。所不同的是，<code>ARG</code> 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的</p>]]></content>
      
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Decker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-学习中..</title>
      <link href="/2023/07/29/python/"/>
      <url>/2023/07/29/python/</url>
      
        <content type="html"><![CDATA[<h1 id="Python语言的特点"><a class="header-anchor" href="#Python语言的特点">¶</a>Python语言的特点</h1><ul><li>-Python语言是通用语言⭐</li><li>**1.易于学习：**Python有相对较少的关键字，结构简单，和一个明确定义的语法，学习起来更加简单。</li><li>**2.易于阅读：**Python代码定义的更清晰。</li><li>**3.易于维护：**Python的成功在于它的源代码是相当容易维护的。</li><li>**4.一个广泛的标准库：**Python的最大的优势之一是丰富的库，跨平台的，在UNIX，Windows和Macintosh兼容很好。</li><li>**5.互动模式：**互动模式的支持，您可以从终端输入执行代码并获得结果的语言，互动的测试和调试代码片断。</li><li>**6.可移植：**基于其开放源代码的特性，Python已经被移植（也就是使其工作）到许多平台。</li><li>**7.可扩展：**如果你需要一段运行很快的关键代码，或者是想要编写一些不愿开放的算法，你可以使用C或C++完成那部分程序，然后从你的Python程序中调用。</li><li>**8.数据库：**Python提供所有主要的商业数据库的接口。</li><li>**9.GUI编程：**Python支持GUI可以创建和移植到许多系统调用。</li><li><strong>10.可嵌入:</strong> 你可以将Python嵌入到C/C++程序，让你的程序的用户获得"脚本化"的能力。</li></ul><p><img src="https://pic1.zhimg.com/80/v2-3e9fb071ac83372a61c3bdea3b06cc1a_1440w.webp?source=1940ef5c" alt="Python路线"></p><h1 id="数据类型"><a class="header-anchor" href="#数据类型">¶</a>数据类型</h1><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230713221133475.png" alt="image-20230713221133475"></p><h2 id="运算符"><a class="header-anchor" href="#运算符">¶</a>运算符</h2><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>+</td><td>加</td></tr><tr><td>-</td><td>减</td></tr><tr><td>*</td><td>乘</td></tr><tr><td>/</td><td>除</td></tr><tr><td>//</td><td>取整除</td></tr><tr><td>%</td><td>取余</td></tr><tr><td>**</td><td>指数</td></tr></tbody></table><h2 id="字符串"><a class="header-anchor" href="#字符串">¶</a>字符串</h2><p>字符串有三种定义方式</p><ol><li>单引号定义——可以内含双引号</li><li>双引号定义——可以内含单引号</li><li>三引号定义——可以多行</li></ol><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">place = <span class="string">'永修'</span></span><br><span class="line">place = <span class="string">"永修"</span></span><br><span class="line">place = <span class="string">'''永修'''</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230802155558695.png" alt="image-20230802155558695"></p><p>例如: 对于字符串中有引号的句子,可用<code>\"</code>表示</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">x = <span class="string">"欲买桃花同载酒,\"终不似\",少年游"</span></span><br></pre></td></tr></tbody></table></figure><p><strong>原始字符串</strong>用法–显示字符串原本的形态</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">x = <span class="string">r"D:\t\y\u\i\o\p"</span></span><br></pre></td></tr></tbody></table></figure><p>在每行的末尾使用<code>\</code>,表示执行未结束</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"            @    \n\</span></span><br><span class="line"><span class="string">           / \\         \n\</span></span><br><span class="line"><span class="string">           * *          \n\</span></span><br><span class="line"><span class="string">           * *          \n\</span></span><br><span class="line"><span class="string">           * *          \n\</span></span><br><span class="line"><span class="string">        * * * * *       \n\</span></span><br><span class="line"><span class="string">     * * * * * * * *    \n\</span></span><br><span class="line"><span class="string">* * * * * * * * * * * * *  \n\</span></span><br><span class="line"><span class="string">           * *           \n\</span></span><br><span class="line"><span class="string">           * *          \n\</span></span><br><span class="line"><span class="string">          * * *         \n\</span></span><br><span class="line"><span class="string">        * * * * *"</span>)</span><br></pre></td></tr></tbody></table></figure><p>"+"号只能用来连接字符串类型，因此，需要字符串格式化</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">tel = <span class="number">100</span></span><br><span class="line">t = <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"%d + %d = %d"</span> % (tel,t,tel+t) )</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>%s</th><th>%d</th><th>%f</th></tr></thead><tbody><tr><td>字符串</td><td>整数</td><td>浮点数</td></tr></tbody></table><h3 id="字符串的序号"><a class="header-anchor" href="#字符串的序号">¶</a>字符串的序号</h3><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230727103000510-1690425004808-1.png" alt="image-20230727103000510"></p><h3 id="字符串的使用"><a class="header-anchor" href="#字符串的使用">¶</a>字符串的使用</h3><p>使用[]获取字符串中的一个或多个字符</p><ul><li>索引: 返回的字符串中单个字符&lt;字符串&gt;[M]</li></ul><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">"请输入带有符号的温度值:"</span>[<span class="number">0</span>] 或 TenoStr[-<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 表示第0个及 倒数第1个</span></span><br></pre></td></tr></tbody></table></figure><ul><li>切片: 返回字符串中一段字符子串&lt;字符串&gt;[M:N]</li></ul><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">"请输入带有符号的温度值:"</span>[<span class="number">1</span>:<span class="number">3</span>] 或 TenoStr[<span class="number">0</span>:-<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 表示从0开始但不到3及 从0开始但不到最后一个</span></span><br></pre></td></tr></tbody></table></figure><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230803112924220.png" alt="image-20230803112924220" style="width:50%;"><h2 id="数字类型"><a class="header-anchor" href="#数字类型">¶</a>数字类型</h2><ul><li><p>整数类型（integers）</p><p><strong>一、开头</strong><br>我们都知道<code>0.1 + 0.2 !== 0.3</code>，而是<code>0.30000000000000004</code>，那么是为什么？我们都知道计算机在内部实现中使用的是二进制，0.1也是不例外的，此时我们将0.1转换为二进制数据表示可以表示为：<code>0.0001100110011001100...（1100无限循环）</code>，0.2转换为二进制数据可以表示为<code>0.00110011001100...(1100循环)</code>，此时这两个数均为无限循环小数，那么该如何去存储呢？<br><strong>二、如何存储二进制小数</strong><br>不同的语言可能会有不同的存储标准，<code>javascript</code>中所用到的整数和小数都使用<code>Number</code>类型来保存的，它的实现遵循<code>IEEE 754</code>标准，使用<code>64位</code>固定长度来保存，也就是<code>双精度浮点数</code>。<br><code>双精度浮点数一共占64位</code><br>符号位占一位<br>指数为占11位<br>小数位占52位<br>所以小数部分加上前面的<code>1</code>,最多保存<code>53</code>位。剩余的也就舍去，遵循0舍1入。此时的二进制为：</p><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">0.00011001100110011001100110011001100110011001100110011010</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><p>同理我们得到<code>0.2</code>的舍去结果为：</p><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">0.0011001100110011001100110011001100110011001100110011010</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><p>两者相加得:</p><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">0.00011001100110011001100110011001100110011001100110011010</span> +</span><br><span class="line"><span class="number">0.0011001100110011001100110011001100110011001100110011010</span> =</span><br><span class="line"><span class="number">0.0100110011001100110011001100110011001100110011001100111</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></tbody></table></figure><p><code>0.0100110011001100110011001100110011001100110011001100111的结果就是0.30000000000000004</code>。</p><p><strong>三、解决方法</strong></p><p>Python中使用<a href="https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/9f771f99adca">decimal 模块</a>：decimal意思为十进制，这个模块提供了十进制浮点运算支持</p></li></ul><h2 id="布尔类型（bool）"><a class="header-anchor" href="#布尔类型（bool）">¶</a>布尔类型（bool）</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span>(<span class="string">" "</span>)</span><br><span class="line"><span class="literal">True</span> == <span class="number">1</span> <span class="comment">#True</span></span><br><span class="line"><span class="literal">False</span> == <span class="number">0</span> <span class="comment">#True</span></span><br><span class="line"><span class="literal">True</span> + <span class="literal">False</span> <span class="comment"># 1</span></span><br><span class="line"><span class="literal">True</span> - <span class="literal">False</span> <span class="comment"># 1</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230804165044734.png" alt="image-20230804165044734"></p><h2 id="逻辑运算符"><a class="header-anchor" href="#逻辑运算符">¶</a>逻辑运算符</h2><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230804165451924.png" alt="image-20230804165451924"></p><p>Python中任何对象都能直接进行<code>真值测试</code>（测试该对象的布尔类型值为True或者False),用于if或者while语句的条件判断，也可以做为布尔逻辑运算符的操作数。</p><ul><li>and取第一个False值，最后一个True值</li></ul><h1 id="变量"><a class="header-anchor" href="#变量">¶</a>变量</h1><p>在Python3.0中变量支持使用中文 <code>正 = 5</code></p><p>且若是想将两数调换,不需要创建新变量</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">x = <span class="number">1</span></span><br><span class="line">y = <span class="number">2</span></span><br><span class="line">x, y = y, x</span><br><span class="line"><span class="comment"># 不是相互调换,是右边覆盖左边,详见牛客NP28</span></span><br><span class="line"><span class="built_in">print</span>(x, y)</span><br><span class="line"><span class="comment"># 输出2, 1 , 优雅😎</span></span><br></pre></td></tr></tbody></table></figure><p><a href="https://www.nowcoder.com/practice/36641ab168664384aff798ba7ce34bc1?tpId=314&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=0&amp;sourceUrl=https%3A%2F%2Fwww.nowcoder.com%2Fexam%2Foj">牛客NP28</a></p><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230804152909666.png" alt="image-20230804152909666"></p><h2 id="数据类型转换"><a class="header-anchor" href="#数据类型转换">¶</a>数据类型转换</h2><p>数据类型转换，将会是我们以后经常使用的功能。如：</p><ul><li>从文件中读取的数字，默认是字符串，我们需要转换成数字类型</li><li>后续学习的iput()语句，默认结果是字符串，若需要数字也需要转换</li><li>将数字转换成字符串用以写出到外部系统</li><li>等等</li></ul><h2 id="列表类型"><a class="header-anchor" href="#列表类型">¶</a>列表类型</h2><p>由0个或多个数据组成的有序序列</p><ul><li>列表使用[]表示,采用<code>,</code>分隔各元素[‘F’,‘f]表示两个元素’F’和’f’</li><li>使用保留字in判断一个元素是否在列表中<code>TempStr[-1] in ['C' , 'c']</code>判断前者是否与列表中某个元素相同</li></ul><h1 id="列表"><a class="header-anchor" href="#列表">¶</a>列表</h1><h2 id="序列"><a class="header-anchor" href="#序列">¶</a>序列</h2><p>序列是 Python 中最基本的数据结构。</p><p>序列中的每个值都有对应的位置值，称之为索引，第一个索引是 0，第二个索引是 1，依此类推。</p><p><img src="https://www.runoob.com/wp-content/uploads/2014/05/positive-indexes-1.png" alt=""></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [a, b, c, d, e, f]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[<span class="number">0</span>]) <span class="comment"># a</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[<span class="number">1</span>]) <span class="comment"># b</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[<span class="number">2</span>]) <span class="comment"># c</span></span><br></pre></td></tr></tbody></table></figure><p>索引也可以从尾部开始，最后一个元素的索引为 <strong>-1</strong>，往前一位为 <strong>-2</strong>，以此类推。</p><p><img src="https://www.runoob.com/wp-content/uploads/2014/05/negative-indexes.png" alt=""></p><ul><li><strong>range(stop)</strong>——range（结尾）</li><li><strong>range(start,stop)</strong>——range（开始，结尾）</li><li><strong>range(start,stop,step)</strong>——range（开始，结尾，跨度）</li></ul><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[<span class="number">0</span>])<span class="comment"># a</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[-<span class="number">1</span>])<span class="comment"># f</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[<span class="number">0</span>:<span class="number">3</span>])<span class="comment"># ['a', 'b', 'c']</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[:<span class="number">2</span>])<span class="comment"># ['a', 'b']</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[:])<span class="comment"># ['a', 'b', 'c', 'd', 'e', 'f']</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[<span class="number">0</span>:<span class="number">6</span>:<span class="number">2</span>])<span class="comment"># ['a', 'c', 'e']</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[::<span class="number">2</span>])<span class="comment"># ['a', 'c', 'e']</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[::-<span class="number">2</span>])<span class="comment"># ['f', 'd', 'b']</span></span><br></pre></td></tr></tbody></table></figure><h2 id="列表增加（append-）"><a class="header-anchor" href="#列表增加（append-）">¶</a>列表增加（append()）</h2><p>==在列表的末尾来添加一个指定的元素==, 你可以对列表的数据项进行修改或更新，你也可以使用 append() 方法来添加列表项，如下所示：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">heros = [<span class="string">"钢铁侠"</span>，<span class="string">"绿巨人"</span>]</span><br><span class="line">heros.append(<span class="string">"美队"</span>)</span><br><span class="line"><span class="built_in">print</span>(heros)<span class="comment"># ["钢铁侠"，"绿巨人"，"美队"]</span></span><br><span class="line">heros.extend(<span class="string">"鹰眼"</span>，<span class="string">"雷神"</span>，<span class="string">"黑寡妇"</span>)</span><br><span class="line"><span class="built_in">print</span>(heros)<span class="comment"># ["钢铁侠"，"绿巨人"，"美队"，"鹰眼"，"雷神"，"黑寡妇"]</span></span><br></pre></td></tr></tbody></table></figure><p>Python包含以下方法:</p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">方法</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-att-list-append.html">list.append(obj)</a> 在列表末尾添加新的对象</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-att-list-count.html">list.count(obj)</a> 统计某个元素在列表中出现的次数</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-att-list-extend.html">list.extend(seq)</a> 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-att-list-index.html">list.index(obj)</a> 从列表中找出某个值第一个匹配项的索引位置</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-att-list-insert.html">list.insert(index, obj)</a> 将对象插入列表, index代表序号</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-att-list-pop.html">list.pop([index=-1])</a> 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-att-list-remove.html">list.remove(obj)</a> 移除列表中某个值的第一个匹配项</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-att-list-reverse.html">list.reverse()</a> 反向列表中元素</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-att-list-sort.html">list.sort( key=None, reverse=False)</a> 对原列表进行排序</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-att-list-clear.html">list.clear()</a> 清空列表</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-att-list-copy.html">list.copy()</a> 复制列表</td></tr></tbody></table><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">hexos[hexos(index(<span class="string">"美队"</span>))] = <span class="string">"蜘蛛侠"</span></span><br><span class="line"><span class="comment"># 查找并输出对象序号,进行更换</span></span><br></pre></td></tr></tbody></table></figure><h2 id="排序"><a class="header-anchor" href="#排序">¶</a>排序</h2><p><a href="https://www.runoob.com/python/att-list-sort.html">sort</a>，如果指定参数，则使用比较函数指定的比较函数。</p><p><a href="https://www.runoob.com/python/att-list-sort.html">reverse</a> 排序规则，<strong>reverse = True</strong> 降序， <strong>reverse = False</strong> 升序（默认）。</p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line">sort(key, reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 为降序排列, 比如 从小到大 改成 从大到小,字符串则按编码大小</span></span><br><span class="line">key.reverse()</span><br><span class="line"><span class="comment"># 为反向排序, 比如10086 改成 68001</span></span><br></pre></td></tr></tbody></table></figure><h2 id="嵌套"><a class="header-anchor" href="#嵌套">¶</a>嵌套</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[<span class="number">0</span>]) <span class="comment"># [1, 2, 3] 序号为0的列表</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[<span class="number">0</span>][<span class="number">0</span>])<span class="comment"># 1 序号为0的列表中的第0对象</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line">A = [<span class="number">0</span>] * <span class="number">3</span><span class="comment"># [[0, 0, 0],[0, 0, 0],[0, 0, 0]]</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    A[i] = [<span class="number">0</span>] * <span class="number">3</span></span><br><span class="line">    </span><br><span class="line">B = [[<span class="number">0</span>] * <span class="number">3</span>] * <span class="number">3</span><span class="comment"># [[0, 0, 0],[0, 0, 0],[0, 0, 0]]</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230807001249299.png" alt="image-20230807001249299"></p><p><code>is</code>类似于Java中的id地址判断，为布尔类型</p><h2 id="变量不是盒子"><a class="header-anchor" href="#变量不是盒子">¶</a>变量不是盒子</h2><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230807143354309.png" alt="image-20230807143354309"></p><p>彼此会随着对方的改变而改变，为避免这种情况，可采用<code>浅拷贝和深拷贝</code>的方法</p><h3 id="浅拷贝"><a class="header-anchor" href="#浅拷贝">¶</a>浅拷贝</h3><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">y = x.copy()</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">y = x[:]</span><br></pre></td></tr></tbody></table></figure><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230807143808466.png" alt="image-20230807143808466" style="zoom:150%;"><h3 id="深拷贝"><a class="header-anchor" href="#深拷贝">¶</a>深拷贝</h3><p>浅拷贝只是拷贝了外层的对象,如果包含嵌套对象的话,拷贝的这是其引用</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">x = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">y = x.copy()</span><br><span class="line">x[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"><span class="comment"># x --&gt; [[1, 2, 3],[4, 0, 6],[7, 8, 9]]</span></span><br><span class="line"><span class="comment"># y --&gt; [[1, 2, 3],[4, 0, 6],[7, 8, 9]]</span></span><br></pre></td></tr></tbody></table></figure><p>使用深拷贝步骤:</p><ol><li><p><code>import copy</code>导入copy模块</p></li><li><pre><code class="language-py">x = [[1, 2, 3],[4, 0, 6],[7, 8, 9]]y = copy.deepcopy(x)<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">   使用`copy模块`下的`deepcopy`函数</span><br><span class="line"></span><br><span class="line">   ![image-20230807145401044](https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230807145401044.png)</span><br><span class="line"></span><br><span class="line">## 列表推导式</span><br><span class="line"></span><br><span class="line">```py</span><br><span class="line">x = [i for i in list[:]]</span><br><span class="line">print(x)</span><br></pre></td></tr></tbody></table></figure></code></pre></li></ol><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line">x = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>[:] <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230807175155700.png" alt="image-20230807175155700"></p><h1 id="元组"><a class="header-anchor" href="#元组">¶</a>元组</h1><p>Python 的元组与列表类似，不同之处在于元组的元素不能修改。</p><p>元组使用小括号 <strong>( )</strong>，列表使用方括号 <strong>[ ]</strong>。</p><p>元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。</p><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/tup-2020-10-27-10-26-2.png" alt=""></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">x = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">或</span><br><span class="line">x = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure><p>元组中只包含一个元素时，需要在元素后面添加逗号<code> **,**</code> ，否则括号会被当作运算符使用：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup1 = (<span class="number">50</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(tup1) &nbsp; &nbsp; <span class="comment"># 不加逗号，类型为整型</span></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">'int'</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup1 = (<span class="number">50</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(tup1) &nbsp; &nbsp; <span class="comment"># 加上逗号，类型为元组</span></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">'tuple'</span>&gt;</span><br></pre></td></tr></tbody></table></figure><h2 id="元组的访问"><a class="header-anchor" href="#元组的访问">¶</a>元组的访问</h2><p>元组可以使用下标索引来访问元组中的值，如下实例:</p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line">tup1 = (<span class="string">'Google'</span>, <span class="string">'Runoob'</span>, <span class="number">1997</span>, <span class="number">2000</span>)</span><br><span class="line">tup2 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> )</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (tup1[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span> (tup2[<span class="number">1</span>:<span class="number">5</span>])</span><br></pre></td></tr></tbody></table></figure><h2 id="元组的修改"><a class="header-anchor" href="#元组的修改">¶</a>元组的修改</h2><p>元组中的元素值是不允许修改的，但我们可以对元组进行连接组合，如下实例:</p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line">tup1 = (<span class="number">12</span>, <span class="number">34.56</span>)</span><br><span class="line">tup2 = (<span class="string">'abc'</span>, <span class="string">'xyz'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 以下修改元组元素操作是非法的。</span></span><br><span class="line"><span class="comment"># tup1[0] = 100</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建一个新的元组</span></span><br><span class="line">tup3 = tup1 + tup2</span><br><span class="line"><span class="built_in">print</span> (tup3)</span><br></pre></td></tr></tbody></table></figure><h1 id="字符串-v2"><a class="header-anchor" href="#字符串-v2">¶</a>字符串</h1><h2 id="左右对齐"><a class="header-anchor" href="#左右对齐">¶</a>左右对齐</h2><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230808154700862.png" alt="image-20230808154700862"></p><h2 id="查找"><a class="header-anchor" href="#查找">¶</a>查找</h2><ul><li><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230808181637483.png" alt="image-20230808181637483" style="zoom: 50%;"></li><li><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230808181732403.png" alt="image-20230808181732403" style="zoom:50%;"></li><li><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230808181800195.png" alt="image-20230808181800195" style="zoom:50%;"></li><li><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230808183000201.png" alt="image-20230808183000201"></li><li><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230808183017857.png" alt="image-20230808183017857"></li></ul><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230808183309724.png" alt="image-20230808183309724"></p><h2 id="替换"><a class="header-anchor" href="#替换">¶</a>替换</h2><p>**expandtabs**--&gt;将tab换成空格</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">y = <span class="string">"""欲买桂花同载酒</span></span><br><span class="line"><span class="string">\t终不似       </span></span><br><span class="line"><span class="string">    少年游"""</span>           <span class="comment"># 有的版本用Tab没用，用\t代替Tab键</span></span><br><span class="line"><span class="built_in">print</span>(y.expandtabs(<span class="number">2</span>)) <span class="comment"># 参数是指定一个tab等于多少个空格</span></span><br></pre></td></tr></tbody></table></figure><p><strong>replace(old, new ,<code>count=-1</code>)</strong> --&gt;更换字符, 默认是全部替换，设置count更换第几个</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">z = <span class="string">"""刮风这天，我试过握着你手，但偏偏，</span></span><br><span class="line"><span class="string">        雨渐渐，大到我看你不见"""</span></span><br><span class="line"><span class="built_in">print</span>(z.replace(<span class="string">'雨渐渐'</span>, <span class="string">'风渐渐'</span>))</span><br></pre></td></tr></tbody></table></figure><p><strong>maketrans 和 translate</strong>--&gt;制表，将表中对应的字符替换</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">list3 = <span class="built_in">str</span>.maketrans(<span class="string">'abcdefg'</span>, <span class="string">'1234567'</span>)</span><br><span class="line">list3_1 = <span class="string">'I am a student'</span>.translate(list3)</span><br><span class="line"><span class="built_in">print</span>(list3_1)  </span><br><span class="line"><span class="comment"># I 1m 1 stu45nt</span></span><br></pre></td></tr></tbody></table></figure><h2 id="判断"><a class="header-anchor" href="#判断">¶</a>判断</h2><p><strong>startswith(prefix[,start[,end]])</strong>--&gt;判断对应字符是否出现在起始位置</p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line">x = <span class="string">'琥珀色黄昏像糖在很美的远方'</span></span><br><span class="line">x.startswith(<span class="string">'琥珀'</span>)</span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></tbody></table></figure><p><strong>endswith(suffix[,start[,end]])</strong> --&gt;判断对应字符是否出现在末尾位置</p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>.endswith(<span class="string">'远方'</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>.endswith(<span class="string">'黄昏'</span>, <span class="number">0</span>, <span class="number">5</span>))</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>istitle(0)</strong>--&gt;判断单词开头是否大写,其余小写</li><li><strong>isupper()</strong>                               --&gt;判断所有字母是否大写</li><li><strong>isaloha()</strong>                                   --&gt;判断字符串中是否只是由字母构成(空格不算字母)</li><li><strong>isspace()</strong>                                   --&gt;判断是否是空白字符串</li><li><strong>isprintable()</strong>                               --&gt;判断字符串是否<code>全部</code>可打印(\n等不行)</li><li><strong>isdecimal()</strong>                                --&gt;判断字符串中只有十进制字符</li><li><strong>isdigit()</strong>    --&gt;判断字符串中的所有字符都是数字，并且在字符串中至少有一个字符</li><li><strong>isnumeric()</strong>--&gt;判断字符串中只有数字字符(包括罗马数字、中文数字)</li><li><strong>isalnum()</strong>                                  --&gt;达成以上3种任意一个,即True</li><li><strong>isidentifier()</strong>                               --&gt;判断字符串是否是有效标识符</li></ul><p>判断一个字符串是否是Python的保留关键字<code>keyword模块</code>的<code>iskeyword</code>函数</p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> keyword</span><br><span class="line">keyword.iskeyword(<span class="string">'if'</span>)</span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></tbody></table></figure><h2 id="截取"><a class="header-anchor" href="#截取">¶</a>截取</h2><p><strong>lstrip()</strong>--&gt;去除左侧的空白</p><p><strong>rstrip()</strong>   --&gt;去除右侧的空白</p><p><strong>strip()</strong>--&gt;去除左右的空白</p><p>括号内可设置想要去除的字符</p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = <span class="string">'www.alesmicb.online'</span></span><br><span class="line"><span class="built_in">list</span>.lstrip(<span class="string">'w.'</span>)</span><br><span class="line"><span class="comment"># alesmicb.online</span></span><br></pre></td></tr></tbody></table></figure><p><strong>removesuffix(<code>'指定字符'</code>)</strong>                               --&gt;去除指定字符串</p><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230809143456716.png" alt="image-20230809143456716"></p><h2 id="拆分和拼接"><a class="header-anchor" href="#拆分和拼接">¶</a>拆分和拼接</h2><p><strong>partition()</strong>                                     --&gt;从左到右找字符进行拆分,返回三元字符串</p><p><strong>rpartition()</strong>                                    --&gt;从右到左找字符进行拆分,返回三元字符串</p><p><strong>split(sep=None,maxsplit=-1)</strong>                 --&gt;以sep进行分割,maxsplit为次数</p><p><strong>rsplit(sep=None,maxsplit=-1)</strong>--&gt;同上,从右到左</p><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230809152831651.png" alt="image-20230809152831651"></p><p><strong>splitlines(keepends=False)</strong>                         --&gt;按行进行分割,并以列表的形式返回</p><p><strong>join()</strong>                                                --&gt;设置指定字符进行拼接</p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">'.'</span>.join([<span class="string">'www'</span>, <span class="string">'alesmicb'</span>, <span class="string">'online'</span>])</span><br><span class="line"><span class="comment"># 'www.alesmicb.online'</span></span><br></pre></td></tr></tbody></table></figure><h2 id="格式化字符串"><a class="header-anchor" href="#格式化字符串">¶</a>格式化字符串</h2><p><a href="https://www.w3school.com.cn/python/ref_string_format.asp"><strong>format</strong></a>                                                --&gt;format() 方法格式化指定的值，并将其插入字符串的占位符内。占位符使用大括号 {} 定义。format() 方法返回格式化的字符串。</p><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230809170330519.png" alt="image-20230809170330519"></p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/Snipaste_2023-08-09_17-43-30.png" alt="img2" style="zoom: 80%;"><table><thead><tr><th style="text-align:left">数字</th><th style="text-align:left">格式</th><th style="text-align:left">输出</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">3.1415926</td><td style="text-align:left">{:.2f}</td><td style="text-align:left">3.14</td><td style="text-align:left">保留小数点后两位</td></tr><tr><td style="text-align:left">3.1415926</td><td style="text-align:left">{:+.2f}</td><td style="text-align:left">+3.14</td><td style="text-align:left">带符号保留小数点后两位</td></tr><tr><td style="text-align:left">-1</td><td style="text-align:left">{:-.2f}</td><td style="text-align:left">-1.00</td><td style="text-align:left">带符号保留小数点后两位</td></tr><tr><td style="text-align:left">2.71828</td><td style="text-align:left">{:.0f}</td><td style="text-align:left">3</td><td style="text-align:left">不带小数</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">{:0&gt;2d}</td><td style="text-align:left">05</td><td style="text-align:left">数字补零 (填充左边, 宽度为2)</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">{:x&lt;4d}</td><td style="text-align:left">5xxx</td><td style="text-align:left">数字补x (填充右边, 宽度为4)</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left">{:x&lt;4d}</td><td style="text-align:left">10xx</td><td style="text-align:left">数字补x (填充右边, 宽度为4)</td></tr><tr><td style="text-align:left">1000000</td><td style="text-align:left">{:,}</td><td style="text-align:left">1,000,000</td><td style="text-align:left">以逗号分隔的数字格式</td></tr><tr><td style="text-align:left">0.25</td><td style="text-align:left">{:.2%}</td><td style="text-align:left">25.00%</td><td style="text-align:left">百分比格式</td></tr><tr><td style="text-align:left">1000000000</td><td style="text-align:left">{:.2e}</td><td style="text-align:left">1.00e+09</td><td style="text-align:left">指数记法</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left">{:&gt;10d}</td><td style="text-align:left">13</td><td style="text-align:left">右对齐 (默认, 宽度为10)</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left">{:&lt;10d}</td><td style="text-align:left">13</td><td style="text-align:left">左对齐 (宽度为10)</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left">{:^10d}</td><td style="text-align:left">13</td><td style="text-align:left">中间对齐 (宽度为10)</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left"><code>'{:b}'.format(11) '{:d}'.format(11) '{:o}'.format(11) '{:x}'.format(11) '{:#x}'.format(11) '{:#X}'.format(11)</code></td><td style="text-align:left"><code>1011 11 13 b 0xb 0XB</code></td><td style="text-align:left">进制</td></tr></tbody></table><p><strong>^</strong>, <strong>&lt;</strong>, <strong>&gt;</strong> 分别是居中、左对齐、右对齐，后面带宽度， <strong>:</strong> 号后面带填充的字符，只能是一个字符，不指定则默认是用空格填充。</p><p><strong>+</strong> 表示在正数前显示 <strong>+</strong>，负数前显示 <strong>-</strong>； （空格）表示在正数前加空格</p><p>b、d、o、x 分别是二进制、十进制、八进制、十六进制。</p><h2 id="f-字符串"><a class="header-anchor" href="#f-字符串">¶</a>f-字符串</h2><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230809175717965.png" alt="image-20230809175717965"></p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">F'我顶着大<span class="subst">{太阳}</span>，只想为你撑伞'</span></span><br><span class="line"><span class="string">f'1+2=<span class="subst">{<span class="number">1</span>+<span class="number">2</span>}</span>,2的平方是<span class="subst">{<span class="number">2</span>*<span class="number">2</span>}</span>,3的立方是<span class="subst">{<span class="number">3</span>*<span class="number">3</span>*<span class="number">3</span>}</span>'</span></span><br></pre></td></tr></tbody></table></figure><h2 id="总结🥲"><a class="header-anchor" href="#总结🥲">¶</a>总结🥲</h2><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/python/ref_string_capitalize.asp">capitalize()</a></td><td style="text-align:left">把首字符转换为大写。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/python/ref_string_casefold.asp">casefold()</a></td><td style="text-align:left">把字符串转换为小写。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/python/ref_string_center.asp">center()</a></td><td style="text-align:left">返回居中的字符串。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/python/ref_string_count.asp">count()</a></td><td style="text-align:left">返回指定值在字符串中出现的次数。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/python/ref_string_encode.asp">encode()</a></td><td style="text-align:left">返回字符串的编码版本。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/python/ref_string_endswith.asp">endswith()</a></td><td style="text-align:left">如果字符串以指定值结尾，则返回 true。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/python/ref_string_expandtabs.asp">expandtabs()</a></td><td style="text-align:left">设置字符串的 tab 尺寸。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/python/ref_string_find.asp">find()</a></td><td style="text-align:left">在字符串中搜索指定的值并返回它被找到的位置。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/python/ref_string_format.asp">format()</a></td><td style="text-align:left">格式化字符串中的指定值。</td></tr><tr><td style="text-align:left">format_map()</td><td style="text-align:left">格式化字符串中的指定值。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/python/ref_string_index.asp">index()</a></td><td style="text-align:left">在字符串中搜索指定的值并返回它被找到的位置。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/python/ref_string_isalnum.asp">isalnum()</a></td><td style="text-align:left">如果字符串中的所有字符都是字母数字，则返回 True。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/python/ref_string_isalpha.asp">isalpha()</a></td><td style="text-align:left">如果字符串中的所有字符都在字母表中，则返回 True。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/python/ref_string_isdecimal.asp">isdecimal()</a></td><td style="text-align:left">如果字符串中的所有字符都是小数，则返回 True。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/python/ref_string_isdigit.asp">isdigit()</a></td><td style="text-align:left">如果字符串中的所有字符都是数字，则返回 True。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/python/ref_string_isidentifier.asp">isidentifier()</a></td><td style="text-align:left">如果字符串是标识符，则返回 True。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/python/ref_string_islower.asp">islower()</a></td><td style="text-align:left">如果字符串中的所有字符都是小写，则返回 True。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/python/ref_string_isnumeric.asp">isnumeric()</a></td><td style="text-align:left">如果字符串中的所有字符都是数，则返回 True。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/python/ref_string_isprintable.asp">isprintable()</a></td><td style="text-align:left">如果字符串中的所有字符都是可打印的，则返回 True。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/python/ref_string_isspace.asp">isspace()</a></td><td style="text-align:left">如果字符串中的所有字符都是空白字符，则返回 True。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/python/ref_string_istitle.asp">istitle()</a></td><td style="text-align:left">如果字符串遵循标题规则，则返回 True。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/python/ref_string_isupper.asp">isupper()</a></td><td style="text-align:left">如果字符串中的所有字符都是大写，则返回 True。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/python/ref_string_join.asp">join()</a></td><td style="text-align:left">把可迭代对象的元素连接到字符串的末尾。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/python/ref_string_ljust.asp">ljust()</a></td><td style="text-align:left">返回字符串的左对齐版本。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/python/ref_string_lower.asp">lower()</a></td><td style="text-align:left">把字符串转换为小写。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/python/ref_string_lstrip.asp">lstrip()</a></td><td style="text-align:left">返回字符串的左修剪版本。</td></tr><tr><td style="text-align:left">maketrans()</td><td style="text-align:left">返回在转换中使用的转换表。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/python/ref_string_partition.asp">partition()</a></td><td style="text-align:left">返回元组，其中的字符串被分为三部分。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/python/ref_string_replace.asp">replace()</a></td><td style="text-align:left">返回字符串，其中指定的值被替换为指定的值。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/python/ref_string_rfind.asp">rfind()</a></td><td style="text-align:left">在字符串中搜索指定的值，并返回它被找到的最后位置。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/python/ref_string_rindex.asp">rindex()</a></td><td style="text-align:left">在字符串中搜索指定的值，并返回它被找到的最后位置。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/python/ref_string_rjust.asp">rjust()</a></td><td style="text-align:left">返回字符串的右对齐版本。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/python/ref_string_rpartition.asp">rpartition()</a></td><td style="text-align:left">返回元组，其中字符串分为三部分。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/python/ref_string_rsplit.asp">rsplit()</a></td><td style="text-align:left">在指定的分隔符处拆分字符串，并返回列表。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/python/ref_string_rstrip.asp">rstrip()</a></td><td style="text-align:left">返回字符串的右边修剪版本。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/python/ref_string_split.asp">split()</a></td><td style="text-align:left">在指定的分隔符处拆分字符串，并返回列表。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/python/ref_string_splitlines.asp">splitlines()</a></td><td style="text-align:left">在换行符处拆分字符串并返回列表。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/python/ref_string_startswith.asp">startswith()</a></td><td style="text-align:left">如果以指定值开头的字符串，则返回 true。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/python/ref_string_strip.asp">strip()</a></td><td style="text-align:left">返回字符串的剪裁版本。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/python/ref_string_swapcase.asp">swapcase()</a></td><td style="text-align:left">切换大小写，小写成为大写，反之亦然。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/python/ref_string_title.asp">title()</a></td><td style="text-align:left">把每个单词的首字符转换为大写。</td></tr><tr><td style="text-align:left">translate()</td><td style="text-align:left">返回被转换的字符串。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/python/ref_string_upper.asp">upper()</a></td><td style="text-align:left">把字符串转换为大写。</td></tr><tr><td style="text-align:left"><a href="https://www.w3school.com.cn/python/ref_string_zfill.asp">zfill()</a></td><td style="text-align:left">在字符串的开头填充指定数量的 0 值。</td></tr></tbody></table><h1 id="序列-v2"><a class="header-anchor" href="#序列-v2">¶</a>序列</h1><p>列表、元组和字符串似乎有很多共同点？</p><p>1.都可以通过索引获取每一个元素</p><p>2.第一个元素的索引值都是0</p><p>3.都可以通过切片的方法获取一个范围</p><p>4.都有很多共同的运算符</p><p>即列表和元组统称为序列</p><h2 id="符号"><a class="header-anchor" href="#符号">¶</a>符号</h2><p>在序列中只有 + 喝 * 可以用，序列的加法表示两个序列进行拼接，乘法表示将序列进行重复==拷贝</p><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230810152057953.png" alt="image-20230810152057953"></p><p><code>del</code>方法可以删除变量</p><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230810155219970.png" alt="image-20230810155219970"></p><h2 id="序列相关的函数"><a class="header-anchor" href="#序列相关的函数">¶</a>序列相关的函数</h2><p><a href="https://www.runoob.com/python/att-tuple-tuple.html">tuple</a>                                       --&gt;将列表转换为元组</p><p>min                                         --&gt;传入数字会返回最小值,传入字符串返回最小编码值的字符</p><p>max--&gt;传入数字会返回最大值,传入字符串返回最大编码值的字符</p><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230810160528164.png" alt="image-20230810160528164"></p><p>len                                          --&gt;返回序列长度</p><p>sum                                        --&gt;返回序列数字类型相加的结果</p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">sum</span>(x)<span class="comment"># 15</span></span><br><span class="line"><span class="built_in">sum</span>(x, start=<span class="number">100</span>)<span class="comment"># 115</span></span><br></pre></td></tr></tbody></table></figure><p>sorted                                      --&gt;排序并==生成新的列表==,sort则是直接改变原本的列表</p><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230810161705293.png" alt="image-20230810161705293"></p><p>all,any</p><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230810163838880.png" alt="image-20230810163838880"></p><p>enumeratezip</p><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230810184330331.png" alt="image-20230810184330331"></p><p><a href="https://www.runoob.com/python3/python3-func-map.html">map</a>                                   --&gt; 函数会根据提供的函数对指定序列做映射</p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>(function, iterable, ...)</span><br><span class="line">function -- 函数</span><br><span class="line">iterable -- 一个或多个序列</span><br></pre></td></tr></tbody></table></figure><p><a href="https://www.runoob.com/python/python-func-filter.html">filter</a>--&gt;函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表</p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">filter</span>(function, iterable)</span><br><span class="line">function -- 判断函数。</span><br><span class="line">iterable -- 可迭代对象。</span><br></pre></td></tr></tbody></table></figure><p>==map和filter的不同在于: map是给出指令给序列执行,filter是给出判断条件对序列进行筛选==</p><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230811012712026.png" alt="image-20230811012712026"></p><h2 id="迭代器和可迭代对象"><a class="header-anchor" href="#迭代器和可迭代对象">¶</a>迭代器和可迭代对象</h2><ul><li>迭代器只能运行一次</li><li>可迭代对象可多次使用</li></ul><p>序列都是可迭代对象,使用<code>iter()</code>函数可使可迭代对象转换成迭代器,<code>next()</code>函数可逐个将迭代器里的元素提取出来</p><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230811013614576.png" alt="image-20230811013614576"></p><h1 id="字典"><a class="header-anchor" href="#字典">¶</a>字典</h1><p>字典是另一种可变容器模型，且可存储任意类型对象。</p><p>字典的每个键值 <strong>key=&gt;value</strong> 对用冒号 <strong>:</strong> 分割，每个对之间用逗号(<strong>,</strong>)分割，整个字典包括在花括号 <strong>{}</strong> 中 ,格式如下所示：</p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line">d = {key1 : value1, key2 : value2, key3 : value3 }</span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230811144555369.png" alt="image-20230811144555369"></p><h2 id="字典的执行"><a class="header-anchor" href="#字典的执行">¶</a>字典的执行</h2><p><code>fromkeys(iterable[,values])</code>                  --&gt;指定的可迭代对象来创建一个新的字典,并将所有的值初始化为values参数指定的值</p><p>可利用此方法快速初始化</p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line">g = <span class="built_in">dict</span>.fromkeys(<span class="string">'fish'</span>, <span class="number">250</span>)</span><br><span class="line"><span class="comment"># {'f': 250, 'i': 250, 's': 250, 'h': 250}</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230811224201531.png" alt="image-20230811224201531"></p><p><code>clear()</code>方法                             --&gt;清除字典,使字典为空</p><h2 id="字典的更改"><a class="header-anchor" href="#字典的更改">¶</a>字典的更改</h2><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line">g = <span class="built_in">dict</span>.fromkeys(<span class="string">'alesmicb'</span>)</span><br><span class="line"><span class="built_in">print</span>(g)</span><br><span class="line"><span class="comment"># {'a': None, 'l': None, 'e': None, 's': None, 'm': None, 'i': None, 'c': None, 'b': None}</span></span><br><span class="line">g.update({<span class="string">'a'</span>:<span class="number">10</span>, <span class="string">'m'</span>:<span class="number">20</span>})</span><br><span class="line"><span class="built_in">print</span>(g)</span><br><span class="line"><span class="comment"># {'a': 10, 'l': None, 'e': None, 's': None, 'm': 20, 'i': None, 'c': None, 'b': None}</span></span><br></pre></td></tr></tbody></table></figure><p>逐个修改太麻烦了，可以使用update([other])的方法，同时传入多个键值对</p><h2 id="字典的查找"><a class="header-anchor" href="#字典的查找">¶</a>字典的查找</h2><p>字典的查找----输入一个键,返回对应的值</p><p>get(key[,default])         --&gt;设置没有查找到数值时返回的值</p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line">g = <span class="built_in">dict</span>.fromkeys(<span class="string">'alesmicb'</span>)</span><br><span class="line">g[<span class="string">'a'</span>]</span><br><span class="line">get(<span class="string">'x'</span>, <span class="string">'这里没有x'</span>)</span><br></pre></td></tr></tbody></table></figure><p>setdefault方法 --&gt;如果字典中存在,返回对应的值;不存在,则新增一个新的键值对</p><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230811230441119.png" alt="image-20230811230441119"></p><h2 id="视图对象"><a class="header-anchor" href="#视图对象">¶</a>视图对象</h2><p>视图对象即字典的动态视图，这就意味着当字典的内容发生改变的时候，视图对象的内容也会相应地跟着改变。</p><p><code>key()</code>                                                        --&gt;创建键值对的视图对象</p><p><code>values()</code>                                                      --&gt;创建键的视图对象</p><p><code>itens()</code>                                                      --&gt;创建值的视图对象</p><p>当我们删除一个字典中的键或值时,它对应的值或键也会随之改变</p><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230811231359093.png" alt="image-20230811231359093"></p><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230811232342156.png" alt="image-20230811232342156"></p><h2 id="字典的遍历"><a class="header-anchor" href="#字典的遍历">¶</a>字典的遍历</h2><p><a href="https://www.nowcoder.com/practice/03a5031ed7ad4a7db897fd9ed982ea57?tpId=314&amp;tqId=40819&amp;sourceUrl=https%3A%2F%2Fwww.nowcoder.com%2Fexam%2Foj">牛客NP70</a></p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line">cities_dict = {</span><br><span class="line">    <span class="string">"Beijing"</span>: {<span class="string">"Capital"</span>: <span class="string">"China"</span>},</span><br><span class="line">    <span class="string">"Moscow"</span>: {<span class="string">"Capital"</span>: <span class="string">"Russia"</span>},</span><br><span class="line">    <span class="string">"Paris"</span>: {<span class="string">"Capital"</span>: <span class="string">"France"</span>},</span><br><span class="line">}</span><br><span class="line">a = <span class="built_in">sorted</span>(cities_dict)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    inin = cities_dict[i][<span class="string">'Capital'</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f'<span class="subst">{i}</span> is the capital of <span class="subst">{inin}</span>!'</span>)</span><br></pre></td></tr></tbody></table></figure><h1 id="集合"><a class="header-anchor" href="#集合">¶</a>集合</h1><ul><li>元组用小括号表示，里面的元素可以是列表，也可以是字符串，它不可以被修改</li><li>列表用方括号表示，里面的元素只能是字符串，可以被修改</li><li>集合（set）是一个==无序==（排序为随机的）的==不重复==元素序列，可以使用大括号 <strong>{ }</strong> 创建集合，元素之间用逗号 <strong>,</strong> 分隔， 或者也可以使用 <strong>set()</strong> 函数创建集合。</li></ul><p>集合中的元素不会重复，并且可以进行交集、并集、差集等常见的集合操作。</p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line">set1 = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>}            <span class="comment"># 直接使用大括号创建集合</span></span><br><span class="line">set2 = <span class="built_in">set</span>([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])      <span class="comment"># 使用 set() 函数从列表创建集合</span></span><br></pre></td></tr></tbody></table></figure><p>==<strong>注意：</strong>==创建一个空集合必须用 <strong>set()</strong> 而不是 <strong>{ }</strong>，因为 <strong>{ }</strong> 是用来创建一个空字典。</p><h2 id="集合的方法"><a class="header-anchor" href="#集合的方法">¶</a>集合的方法</h2><h3 id="集合内置方法完整列表"><a class="header-anchor" href="#集合内置方法完整列表">¶</a>集合内置方法完整列表</h3><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/ref-set-add.html">add()</a></td><td style="text-align:left">为集合添加元素</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/ref-set-clear.html">clear()</a></td><td style="text-align:left">移除集合中的所有元素</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/ref-set-copy.html">copy()</a></td><td style="text-align:left">浅拷贝一个集合</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/ref-set-difference.html">difference()</a></td><td style="text-align:left">返回多个集合的差集</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/ref-set-difference_update.html">difference_update()</a></td><td style="text-align:left">移除集合中的元素，该元素在指定的集合也存在。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/ref-set-discard.html">discard()</a></td><td style="text-align:left">删除集合中指定的元素</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/ref-set-intersection.html">intersection()</a></td><td style="text-align:left">返回集合的交集</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/ref-set-intersection_update.html">intersection_update()</a></td><td style="text-align:left">返回集合的交集。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/ref-set-isdisjoint.html">isdisjoint()</a></td><td style="text-align:left">判断两个集合是否<strong>包含</strong>相同的元素，如果没有返回 True，否则返回 False。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/ref-set-issubset.html">issubset()</a></td><td style="text-align:left">判断指定集合是否为该方法参数集合的子集。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/ref-set-issuperset.html">issuperset()</a></td><td style="text-align:left">判断该方法的参数集合是否为指定集合的子集</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/ref-set-pop.html">pop()</a></td><td style="text-align:left">随机移除元素</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/ref-set-remove.html">remove()</a></td><td style="text-align:left">移除指定元素</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/ref-set-symmetric_difference.html">symmetric_difference()</a></td><td style="text-align:left">返回两个集合中不重复的元素集合。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/ref-set-symmetric_difference_update.html">symmetric_difference_update()</a></td><td style="text-align:left">移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/ref-set-union.html">union()</a></td><td style="text-align:left">返回两个集合的并集</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/ref-set-update.html">update()</a></td><td style="text-align:left">给集合添加元素</td></tr></tbody></table><h2 id="位运算"><a class="header-anchor" href="#位运算">¶</a>位运算</h2><h3 id="按位与运算符（-）"><a class="header-anchor" href="#按位与运算符（-）">¶</a>按位与<a href="https://so.csdn.net/so/search?q=%E8%BF%90%E7%AE%97%E7%AC%A6&amp;spm=1001.2101.3001.7020">运算符</a>（&amp;）</h3><p>参加运算的两个数，按二进制位进行“与”运算。</p><p>运算规则：==只有两个数的二进制同时为1，结果才为1，否则为0==。（负数按补码形式参加按位与运算）</p><p>即 0 &amp; 0= 0 ，0 &amp; 1= 0，1 &amp; 0= 0， 1 &amp; 1= 1。</p><p>例：3 &amp;5 即 00000011 &amp; 00000101 = 00000001 ，所以 3 &amp; 5的值为1。</p><h3 id="按位或运算符（-）"><a class="header-anchor" href="#按位或运算符（-）">¶</a>按位或运算符（|）</h3><p>参加运算的两个数，按二进制位进行“或”运算。</p><p>运算规则：==参加运算的两个数只要两个数中的一个为1，结果就为1==。</p><p>即 0 | 0= 0 , 1 | 0= 1 ， 0 | 1= 1 , 1 | 1= 1 。</p><p>例：2 | 4 即 00000010 | 00000100 = 00000110 ，所以2 | 4的值为 6 。</p><h3 id="异或运算符（-）"><a class="header-anchor" href="#异或运算符（-）">¶</a>异或运算符（^）</h3><p>参加运算的两个数，按二进制位进行“异或”运算。</p><p>运算规则：参加运算的两个数，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。</p><p>即 0 ^ 0=0 ， 0 ^ 1= 1 ， 1 ^ 0= 1 ， 1 ^ 1= 0 。</p><p>例： 2 ^ 4 即 00000010 ^ 00000100 =00000110 ，所以 2 ^ 4 的值为6 。</p><h1 id="函数"><a class="header-anchor" href="#函数">¶</a>函数</h1><p>函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。</p><p>函数能提高应用的模块性，和代码的重复利用率。你已经知道Python提供了许多内建函数，比如print()。但你也可以自己创建函数，这被叫做用户自定义函数。</p><p>Python函数的主要作用是打包代码：</p><ol><li>可以最大程度的实现代码的重用。减少冗余的代码</li><li>可以将不同功能的代码进行封装，分解，从而降低结构的复杂度</li></ol><h2 id="打包参数"><a class="header-anchor" href="#打包参数">¶</a>打包参数</h2><h3 id="定义一个函数"><a class="header-anchor" href="#定义一个函数">¶</a>定义一个函数</h3><p>你可以定义一个由自己想要功能的函数，以下是简单的规则：</p><ul><li>函数代码块以 <strong>def</strong> 关键词开头，后接函数标识符名称和圆括号 <strong>()</strong>。</li><li>任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。</li><li>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。</li><li>函数内容以冒号 <strong>:</strong> 起始，并且缩进。</li><li><strong>return [表达式]</strong> 结束函数，选择性地返回一个值给调用方，不带表达式的 return 相当于返回 None。</li></ul><h3 id="语法"><a class="header-anchor" href="#语法">¶</a>语法</h3><p>一般形式</p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>() :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Hello World!"</span>)</span><br><span class="line"></span><br><span class="line">hello()</span><br></pre></td></tr></tbody></table></figure><p>更复杂点的应用，函数中带上参数变量:</p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">div</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x / y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(div(<span class="number">10</span>, <span class="number">2</span>))</span><br></pre></td></tr></tbody></table></figure><p>关键字参数:</p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">span</span>(<span class="params">x, y, z</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join((z, x, y))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为join只能接受一个参数，加括号让他变成元组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(span(<span class="string">'icb'</span>, <span class="string">'sm'</span>, <span class="string">'ales'</span>)) <span class="comment"># 位置参数</span></span><br><span class="line"><span class="built_in">print</span>(span(y=<span class="string">'icb'</span>, x=<span class="string">'sm'</span>, z=<span class="string">'ales'</span>))</span><br></pre></td></tr></tbody></table></figure><p><code>help()</code>可以查询函数的参数格式</p><h3 id="收集参数"><a class="header-anchor" href="#收集参数">¶</a>收集参数</h3><p>例如<code>print()</code>一般的函数, 用户想传几个传几个的方法叫<strong>收集参数</strong>,用 ***** 表示</p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">collect</span>(<span class="params">*args</span>):         <span class="comment"># 收集函数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f'有<span class="subst">{<span class="built_in">len</span>(args)}</span>个参数'</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f'第2个参数是<span class="subst">{args[<span class="number">1</span>]}</span>'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">collect(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">13</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="解包参数"><a class="header-anchor" href="#解包参数">¶</a>解包参数</h2><p><code>global()</code>                                                --&gt;修改为全局变量</p><h3 id="嵌套函数"><a class="header-anchor" href="#嵌套函数">¶</a>嵌套函数</h3><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230814022421855.png" alt="image-20230814022421855"></p><p>正确调用内部函数:</p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">num1</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">num2</span>():</span><br><span class="line">         x = <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line">    <span class="keyword">return</span> num2()<span class="comment"># 返回num2,使num2在num1函数中执行</span></span><br><span class="line">num1()</span><br></pre></td></tr></tbody></table></figure><p>外部函数调用内部函数,若想要修改内部函数,需要用<code>nonlocal</code>语句</p><p>nonlocal                                            --&gt;修改外部函数作用域的值(修改上一层)</p><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230814023106691.png" alt="image-20230814023106691"></p><p><strong><a href="https://www.jianshu.com/p/3b72ba5a209c">LEGB规则</a></strong></p><p>Python有多个命名空间，因此，需要有规则来规定，按照怎样的顺序来查找命名空间，<strong>LEGB就是用来规定命名空间查找顺序的规则</strong>。</p><ul><li>L - Locai : 函数内的名字空间</li><li>E - Enclosing function local : 嵌套函数中外部函数的名字空间</li><li>G - Global : 函数定义所在模块的名字空间</li><li>B - Builtin : Python 内置模块的名字空间</li></ul><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="number">100</span><span class="comment"># str为关键字</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)  <span class="comment"># 100</span></span><br></pre></td></tr></tbody></table></figure><p>设置的变量会将函数的意义覆盖</p><h2 id="闭包"><a class="header-anchor" href="#闭包">¶</a>闭包</h2><p>闭包概念：在一个内部函数中，对外部作用域的变量进行引用，(并且一般外部函数的返回值为内部函数)，那么内部函数就被认为是闭包。</p><img src="https://pic3.zhimg.com/80/0bf070da6fba4187510d4f423f451dd2_720w.webp" alt="img" style="zoom:120%;"><p>体现闭包的用法(名字自己取的, 官方不存在这种分类)</p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 普通型</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">num1</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">num2</span>(<span class="params">x1, y1</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> x, y</span><br><span class="line">        x += x1</span><br><span class="line">        y += y1</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f'x=<span class="subst">{x}</span>, y=<span class="subst">{y}</span>'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num2(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num1(<span class="number">20</span>, <span class="number">10</span>)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 记忆性</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">num1</span>():</span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    y = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">num2</span>(<span class="params">x1, y1</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> x, y</span><br><span class="line">        x += x1</span><br><span class="line">        y += y1</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f'x=<span class="subst">{x}</span>, y=<span class="subst">{y}</span>'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">move = num1()</span><br><span class="line">move(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">move(<span class="number">10</span>, <span class="number">30</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="装饰器"><a class="header-anchor" href="#装饰器">¶</a>装饰器</h2><p>装饰器就是一个闭包，装饰器是闭包的一种应用。什么是装饰器呢，简言之，python装饰器就是<strong>用于拓展原来函数功能</strong>的一种函数，这个函数的特殊之处在于它的返回值也是一个函数，使用python装饰器的好处就是在不用更改原函数的代码前提下给函数增加新的功能。使用时，再需要的函数前加上@XXXX即可。</p><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230815002007024.png" alt="image-20230815002007024"></p><p>这段代码是一个使用装饰器的示例，主要用于计算函数执行时长，并在函数开始和结束时打印一些消息。</p><ol><li><p>首先，该代码导入了时间模块<code> time</code>，用于计算代码执行的时间。</p></li><li><p>接下来定义了一个名为 <code>demo()</code> 的函数，该函数接受一个参数<code> x</code>，该参数是一个函数。</p></li><li><p>在 demo() 函数内部，定义了一个名为 <code>call_x()</code> 的函数，它用于在函数<code>x()</code>前后执行一些操作。在这个示例中，它会打印一些消息，记录函数的开始和结束时间，并计算函数执行的时长。</p></li><li><p>demo() 函数最后返回了 <code>call_x() </code>函数对象，即装饰器函数要返回真正的装饰器函数本身。</p></li><li><p>在代码的下一部分，使用装饰器语法将函数<code>y()</code>装饰为 <code>@demo</code>。这样，<code>y()</code> 函数就会被 <code>demo()</code> 函数装饰，相当于<code> y = demo(y)</code>。</p></li><li><p>在<code> y()</code> 函数内部，先通过 time.sleep(5) 休眠 5 秒钟，模拟一个耗时操作。然后打印出字符串 “I love X”。</p></li><li><p>最后，调用<code> y()</code> 函数，实际上是调用装饰后的函数 <code>demo(y)</code>。在这个过程中，由于使用了装饰器，会在函数<code> y()</code> 的执行前后添加了额外的操作。</p></li></ol><p>整体来说，这段代码的作用是在函数<code> y()</code> 执行前后打印一些消息，记录函数执行的时间，并计算函数的时长。可以用于给函数添加一些额外的功能而不修改函数本身的定义。</p><h3 id="time-time"><a class="header-anchor" href="#time-time">¶</a>time().time()</h3><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">"time.time(): %f "</span> %  time.time()</span><br><span class="line"><span class="built_in">print</span> time.localtime( time.time() )</span><br><span class="line"><span class="built_in">print</span> time.asctime( time.localtime(time.time()) )</span><br></pre></td></tr></tbody></table></figure><p>以上实例输出结果为：</p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line">time.time(): <span class="number">1234892919.655932</span></span><br><span class="line">(<span class="number">2009</span>, <span class="number">2</span>, <span class="number">17</span>, <span class="number">10</span>, <span class="number">48</span>, <span class="number">39</span>, <span class="number">1</span>, <span class="number">48</span>, <span class="number">0</span>)</span><br><span class="line">Tue Feb <span class="number">17</span> <span class="number">10</span>:<span class="number">48</span>:<span class="number">39</span> <span class="number">2009</span></span><br></pre></td></tr></tbody></table></figure><h2 id="lambda"><a class="header-anchor" href="#lambda">¶</a>lambda</h2><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230815003049138.png" alt="image-20230815003049138"></p><p>lambda是个表达式</p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">squareX</span>(<span class="params">x</span>):</span><br><span class="line"><span class="keyword">return</span> x * x</span><br><span class="line"></span><br><span class="line">squareX(<span class="number">3</span>)<span class="comment"># 9</span></span><br></pre></td></tr></tbody></table></figure><p>使用lambda则是：</p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line">squareY = <span class="keyword">lambda</span> y : y * y<span class="comment"># :前是参数，后是表达式</span></span><br><span class="line">squareY(<span class="number">3</span>) <span class="comment"># 9</span></span><br></pre></td></tr></tbody></table></figure><h2 id="生成器"><a class="header-anchor" href="#生成器">¶</a>生成器</h2><p>在 Python 中，使用了 <strong>yield</strong> 的函数被称为生成器（generator）。</p><p>使用方法： 生成器可以通过函数+yield语句来定义。当函数执行到yield语句时，会暂停函数的执行，并将yield后的值返回给调用者。调用者可以通过next()函数获取生成器中的下一个值，或使用for循环来遍历生成器。</p><p><strong>相当于调试时输出各个阶段的值</strong></p><p><strong>在实际开发中的应用</strong>：</p><ol><li>节省内存：生成器逐个生成值，不会一次性生成所有值，因此节省了大量的内存空间。特别适合处理大型数据集或无限序列。</li><li>懒加载/惰性计算：生成器在需要时才计算值，避免了不必要的计算。可以应用于惰性计算，例如处理无限序列、大文件、网络请求等。</li><li>高效迭代：生成器提供了一种简洁、高效的方式来进行迭代。通过生成器，可以在迭代过程中实时生成和处理数据，而无需事先存储和加载整个数据集。</li></ol><h3 id="斐波那契数列"><a class="header-anchor" href="#斐波那契数列">¶</a>斐波那契数列</h3><p>由0和1开始，之后的斐波那契数就是由之前的两数相加而得出：0,1,1,2,3,5,8…</p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>():</span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = fib()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(c))</span><br></pre></td></tr></tbody></table></figure><h2 id="函数文档，类型注释，內省"><a class="header-anchor" href="#函数文档，类型注释，內省">¶</a>函数文档，类型注释，內省</h2><h3 id="函数文档是对一个函数进行解释说明"><a class="header-anchor" href="#函数文档是对一个函数进行解释说明">¶</a>函数文档是对一个函数进行解释说明</h3><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">exchange</span>(<span class="params">dollar,rate=<span class="number">6.32</span></span>):</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">功能：汇率转换，美元-&gt;人民币</span></span><br><span class="line"><span class="string">参数：</span></span><br><span class="line"><span class="string">-do1lar美元数量</span></span><br><span class="line"><span class="string">-rate汇率，默认值是6.32(2022-03-08)</span></span><br><span class="line"><span class="string">返回值：</span></span><br><span class="line"><span class="string">·人民币的数量</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">return</span> dollar * rate</span><br></pre></td></tr></tbody></table></figure><h3 id="类型注释"><a class="header-anchor" href="#类型注释">¶</a>类型注释</h3><p>类型注解的作用是提供一种在代码中指定变量和函数的类型信息的方式。类型注解可以帮助开发者更好地理解代码，提高代码可读性，并在开发过程中检测静态类型错误。</p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line">name: <span class="built_in">str</span> = <span class="string">'jay'</span></span><br><span class="line"><span class="built_in">print</span>(name)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello, "</span> + name</span><br></pre></td></tr></tbody></table></figure><h3 id="高阶函数"><a class="header-anchor" href="#高阶函数">¶</a>高阶函数</h3><p>只要满足下面的任意一个条件就是高阶函数</p><ul><li>1、一个函数的<code>函数名</code>作为参数传给另外一个函数</li><li>2、一个函数返回值（return）为另外一个<code>函数</code>（返回为自己，则为递归）</li></ul><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"定义一个普通函数"</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">high_level</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"定义一个高阶函数"</span>)</span><br><span class="line">    <span class="comment"># 在函数内部，通过传入的函数参数调用</span></span><br><span class="line">    func()</span><br><span class="line">    </span><br><span class="line">high_level(func)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">定义一个高阶函数</span></span><br><span class="line"><span class="string">定义一个普通函数</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></tbody></table></figure><h1 id="文件"><a class="header-anchor" href="#文件">¶</a>文件</h1><h2 id="打开文件"><a class="header-anchor" href="#打开文件">¶</a>打开文件</h2><p><img src="Python.assets/image-20230824235552663.png" alt="image-20230824235552663"></p><p>open() 将会返回一个 file 对象，基本语法格式如下:</p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">open</span>(filename, mode)</span><br></pre></td></tr></tbody></table></figure><ul><li>filename：包含了你要访问的文件名称的字符串值。</li><li>mode：决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读®。</li></ul><p>不同模式打开文件的完全列表：</p><table><thead><tr><th style="text-align:left">模式</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">r</td><td style="text-align:left">以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td></tr><tr><td style="text-align:left">rb</td><td style="text-align:left">以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。</td></tr><tr><td style="text-align:left">r+</td><td style="text-align:left">打开一个文件用于读写。文件指针将会放在文件的开头。</td></tr><tr><td style="text-align:left">rb+</td><td style="text-align:left">以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。</td></tr><tr><td style="text-align:left">w</td><td style="text-align:left">打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td style="text-align:left">wb</td><td style="text-align:left">以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td style="text-align:left">w+</td><td style="text-align:left">打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td style="text-align:left">wb+</td><td style="text-align:left">以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td style="text-align:left">a</td><td style="text-align:left">打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td style="text-align:left">ab</td><td style="text-align:left">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td style="text-align:left">a+</td><td style="text-align:left">打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td></tr><tr><td style="text-align:left">ab+</td><td style="text-align:left">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td></tr></tbody></table><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230817154516213.png" alt="image-20230817154516213"></p><h2 id="读文件"><a class="header-anchor" href="#读文件">¶</a>读文件</h2><p><strong>第一种方法</strong></p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>()</span><br><span class="line"><span class="built_in">print</span>(f.read())</span><br></pre></td></tr></tbody></table></figure><ul><li>read()函数会读取文件全部内容</li><li>且内存会记录文件读取的位置</li><li>倘若执行两遍 print(f.read())</li><li>第二遍的内容为空</li><li><strong>读完文件记得使用 close() 方法, 关闭文件, 释放资源</strong></li></ul><p><img src="Python.assets/image-20230825000352976.png" alt="image-20230825000352976"></p><p><img src="Python.assets/image-20230825000506623.png" alt="image-20230825000506623"></p><p><strong>第二种方法</strong>👍</p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'/路径'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="built_in">print</span>(f.read())</span><br></pre></td></tr></tbody></table></figure><p>此方法更为简洁, 且无需使用 <code>close()</code> 方法</p><h1 id="异常"><a class="header-anchor" href="#异常">¶</a>异常</h1><h2 id="处理异常"><a class="header-anchor" href="#处理异常">¶</a>处理异常</h2><p><strong>try-except</strong></p><p>try 语句按照如下方式工作；</p><ul><li>首先，执行 try 子句（在关键字 try 和关键字 except 之间的语句）。</li><li>如果没有异常发生，忽略 except 子句，try 子句执行后结束。</li><li>如果在执行 try 子句的过程中发生了异常，那么 try 子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的 except 子句将被执行。</li><li>如果一个异常没有与任何的 except 匹配，那么这个异常将会传递给上层的 try 中。</li></ul><p><strong>语法</strong></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 可能引发异常的代码</span></span><br><span class="line"><span class="keyword">except</span> ExceptionType <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 异常处理的代码</span></span><br><span class="line">    <span class="comment"># e为错误的原因</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line">举例<span class="number">1</span>:</span><br><span class="line"><span class="comment"># 输入一个非数字的字符串</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">"请输入一个数字: "</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"你输入的数字是:"</span>, num)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"输入的不是有效的数字！"</span>)</span><br></pre></td></tr></tbody></table></figure><p><strong>try-except-else</strong></p><p><img src="https://www.runoob.com/wp-content/uploads/2019/07/try_except_else.png" alt="try1"></p><p><strong>try-except-finally</strong></p><p><img src="https://www.runoob.com/wp-content/uploads/2019/07/try_except_else_finally.png" alt="try2"></p><h2 id="抛出异常"><a class="header-anchor" href="#抛出异常">¶</a>抛出异常</h2><p><code>raise</code> 语句抛出一个指定的异常。</p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">'x 不能大于 5。x 的值为: {}'</span>.<span class="built_in">format</span>(x))</span><br></pre></td></tr></tbody></table></figure><h1 id="面向对象"><a class="header-anchor" href="#面向对象">¶</a>面向对象</h1><p>类里面的方法，必须以self为第一个参数</p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    x = <span class="number">520</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Hello World!"</span>)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, new_name, new_age</span>):</span><br><span class="line">    <span class="string">"""在创建完对象之后 会自动调用, 它完成对象的初始化的功能"""</span></span><br><span class="line">    <span class="comment"># self.name = "汤姆"</span></span><br><span class="line">    <span class="comment"># self.age = 20</span></span><br><span class="line">    self.name = new_name</span><br><span class="line">    self.age = new_age  <span class="comment"># 它是一个对象中的属性,在对象中存储,即只要这个对象还存在,那么这个变量就可以使用</span></span><br><span class="line">    <span class="comment"># num = 100  # 它是一个局部变量,当这个函数执行完之后,这个变量的空间就没有了,因此其他方法不能使用这个变量</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">"""返回一个对象的描述信息"""</span></span><br><span class="line">    <span class="comment"># print(num)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"名字是:%s , 年龄是:%d"</span> % (self.name, self.age)</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="继承"><a class="header-anchor" href="#继承">¶</a>继承</h2><p><strong>isinstance()</strong> 函数来判断一个对象是否是一个已知的类型,比如：</p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;a = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span> (a,<span class="built_in">int</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span> (a,<span class="built_in">str</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span> (a,(<span class="built_in">str</span>,<span class="built_in">int</span>,<span class="built_in">list</span>))    <span class="comment"># 是元组中的一个返回 True</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure><p><strong>issubclass()</strong> 方法用于判断参数 class 是否是类型参数 classinfo 的子类。</p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">issubclass</span>(<span class="keyword">class</span>, classinfo)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    x = <span class="number">520</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"AAAAAAAA"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># class B(A):   继承A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):  <span class="comment"># 继承A</span></span><br><span class="line">    x = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"BBBBBBBB"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(A, B):  <span class="comment"># 多重继承 就近原则，先在A中查找方法</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = C()</span><br><span class="line"><span class="built_in">print</span>(c.x)</span><br><span class="line">c.hello()</span><br></pre></td></tr></tbody></table></figure><h2 id="组合"><a class="header-anchor" href="#组合">¶</a>组合</h2><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230820143231014.png" alt="image-20230820143231014"></p><h2 id="绑定"><a class="header-anchor" href="#绑定">¶</a>绑定</h2><p><code>__dict__</code>--&gt;查看对象<code>属性</code></p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">x = <span class="number">50</span></span><br><span class="line">a = A()</span><br><span class="line">a.__dict__ <span class="comment"># {'x' : 50}</span></span><br></pre></td></tr></tbody></table></figure><p><code>__init__</code>--&gt;初始化实例</p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.x + self.y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.x - self.y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A(<span class="number">100</span>, <span class="number">45</span>)</span><br><span class="line">a.add()     <span class="comment"># 145</span></span><br><span class="line">a.mul()     <span class="comment"># 55</span></span><br></pre></td></tr></tbody></table></figure><p>Object是所有类的根源父类，在类无父类时，<code>super()</code>指向<code>Object类</code>, 因为<code>mro顺序</code>会去寻找同等继承关系的类,</p><p>即调用Object拥有同名的方法的子类</p><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230821233325940.png" alt="image-20230821233325940"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown</title>
      <link href="/2023/07/29/typora-jiao-cheng/"/>
      <url>/2023/07/29/typora-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="Typora教程"><a class="header-anchor" href="#Typora教程">¶</a>Typora教程</h1><p>2023.4.27</p><p>[TOC]</p><h1 id="一、typora的基本使用方法"><a class="header-anchor" href="#一、typora的基本使用方法">¶</a>一、typora的基本使用方法</h1><h2 id="1-标题-ctrl-num"><a class="header-anchor" href="#1-标题-ctrl-num">¶</a>1.标题  <sub>ctrl+num</sub></h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">... ...</span><br></pre></td></tr></tbody></table></figure><p>标题会在目录与大纲分级显示，可以跳转.</p><p>在Typora中建议开启<code>严格模式</code>, 即不应该为<code>#标题</code>,应为<code># 标题</code>.</p><p>应该要手动补上空格, 使得 Markdown 语法在其他文本编辑器上兼容.</p><h2 id="2-强调-用-“或”-包围"><a class="header-anchor" href="#2-强调-用-“或”-包围">¶</a>2.强调  <sub>[用"**“或”__"包围]</sub></h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">**( •̀ ω •́ )✧**</span><br><span class="line">__( •̀ ω •́ )✧__</span><br></pre></td></tr></tbody></table></figure><p>或者选中后搭配快捷键<code>ctrl+b</code></p><p>例子:<strong>( •̀ ω •́ )✧</strong></p><h2 id="3-斜体-用-“或”-包围"><a class="header-anchor" href="#3-斜体-用-“或”-包围">¶</a>3.斜体  <sub>[用"*“或”_"包围]</sub></h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">*(❁´◡`❁)*</span><br><span class="line">_(❁´◡`❁)_</span><br></pre></td></tr></tbody></table></figure><p>或者选中后搭配快捷键<code>ctrl+i</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">***斜体并包围***</span><br></pre></td></tr></tbody></table></figure><p>例子:<em>( •̀ ω •́ )✧</em>  <em><strong>斜体并包围</strong></em></p><h2 id="2-引用-快捷键：-空格"><a class="header-anchor" href="#2-引用-快捷键：-空格">¶</a>2.引用 快捷键：&gt;+空格</h2><p>引用</p><p>快捷键：&gt;+空格</p><p>退出引用：shift+Tab (一般在引用内容写完的下一行使用）</p><h2 id="3-无序列表-快捷键：Ctrl-shift"><a class="header-anchor" href="#3-无序列表-快捷键：Ctrl-shift">¶</a>3.无序列表 快捷键：Ctrl+shift+]</h2><ul><li>例子 （ ]:右中括号 ]</li><li>想要子列表： 按 Tab<br>想要子列表：Tab<br>回到上一层：shift+Tab<br>回到上一层：shift+Tab</li></ul><h2 id="4-有序列表-快捷键：Ctrl-shift"><a class="header-anchor" href="#4-有序列表-快捷键：Ctrl-shift">¶</a>4.有序列表 快捷键：Ctrl+shift+[</h2><ol><li>例子 （ [:左中括号 ]</li><li>想要子列表：按Tab<br>想要子列表：Tab<br>例子<br>回到上一层：shift+Tab<br>回到上一层：shift+Tab</li></ol><h2 id="5-链接-快捷键：-内容-链接"><a class="header-anchor" href="#5-链接-快捷键：-内容-链接">¶</a>5.链接 快捷键： [内容]+(链接)</h2><p>例子： <a href="http://www.baidu.com">百度</a></p><p>快捷键：<code>ctrl + K</code></p><p>注意：<code>( ) 小括号一定要在输入法英文模式下打出</code></p><p>使用方式：</p><ul><li>右键点击-》打开链接</li><li>按住ctrl, 左键点击</li></ul><h2 id="6-图片"><a class="header-anchor" href="#6-图片">¶</a>6.图片</h2><p>插入图片：直接拖动（复制粘贴）到指定位置即可<br>或者ctrl+shift+i</p><p>Typora默认是将所有图片放在一起，如果需要放置指定目录下： Typora的文件—&gt;&gt;&gt;偏好设置</p><p>img文件夹的名称和位置为举例（可随意更改）</p><p>此时插入图片后，图片会保存在img目录下</p><h2 id="7-高亮"><a class="header-anchor" href="#7-高亮">¶</a>7.高亮</h2><p>例子 ： ==这就是高亮==</p><p>快捷键：两个等号+内容+两个等号</p><p>提前要在偏好设置中打开高亮设置：</p><h2 id="8-划重点"><a class="header-anchor" href="#8-划重点">¶</a>8.划重点</h2><p>1.加粗： Ctrl+B</p><p>2.代码：Ctrl+shift+ `</p><p><code>这就是代码</code></p><p>3.删除线： Alt+shift+5</p><p><s>这是删除线</s></p><p>4.斜体： Ctrl+i</p><p><em>这就是斜体</em></p><p>5.下划线：Ctrl+U</p><p><u>这就是下划线</u></p><h2 id="9-表格-快捷键：-Ctrl-T"><a class="header-anchor" href="#9-表格-快捷键：-Ctrl-T">¶</a>9.表格 快捷键： Ctrl+T</h2><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="10-代码块-快捷键：-回车"><a class="header-anchor" href="#10-代码块-快捷键：-回车">¶</a>10.代码块 快捷键：```+回车</h2><p>三个飘号+回车</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">int a=1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line"> （ 可以选择代码语音）</span><br></pre></td></tr></tbody></table></figure><h1 id="二、typora简单偏好设置"><a class="header-anchor" href="#二、typora简单偏好设置">¶</a>二、typora简单偏好设置</h1><h2 id="1-让大纲看起来更舒服"><a class="header-anchor" href="#1-让大纲看起来更舒服">¶</a>1.让大纲看起来更舒服</h2><p>Typora的文件—&gt;&gt;&gt;偏好设置</p><h2 id="2-自动保存（需要重启Typora"><a class="header-anchor" href="#2-自动保存（需要重启Typora">¶</a>2.自动保存（需要重启Typora)</h2><h2 id="3-调试功能及使用（需要重启Typora"><a class="header-anchor" href="#3-调试功能及使用（需要重启Typora">¶</a>3.调试功能及使用（需要重启Typora)</h2><p>（1）勾选开启调试模式</p><p>（2）右键点击检查</p><p>（3）小箭头定位元素</p><p>（4）定位后 可在Style中修改</p><p>(5) 但是关闭重启Typora后，修改的效果会消失</p><p>若想永久生效需要修改主题文件 文件-》偏好设置-》外观-》打开主题文件夹</p>]]></content>
      
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习--B站韩顺平</title>
      <link href="/2023/07/27/java/"/>
      <url>/2023/07/27/java/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-（P433…）"><a class="header-anchor" href="#Java-（P433…）">¶</a>Java （P433…）</h1><h1 id="四种访问修饰符和各自的访问权限"><a class="header-anchor" href="#四种访问修饰符和各自的访问权限">¶</a>四种访问修饰符和各自的访问权限</h1><table><thead><tr><th>1</th><th>本类</th><th>同包</th><th>子类</th><th>不同类</th></tr></thead><tbody><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>默认</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><h1 id="类、属性、方法、局部变量"><a class="header-anchor" href="#类、属性、方法、局部变量">¶</a>类、属性、方法、局部变量</h1><ul><li><strong>对象</strong>：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</li><li><strong>类</strong>：类是一个模板，它描述一类对象的行为和状态。</li></ul><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230702152942116.png" alt="image-20230702152942116"></p><p>创建一个Car类（Class），它的颜色、品牌、型号是对象（Object）</p><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/20210105-java-object-1.png" alt="img"></p><p><strong>方法</strong>可以比作类的行为，eat(),run(),sleep(),name()…</p><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230702154002023-1688283605440-3.png" alt="image-20230702154002023"></p><p>成员变量：表示类方法中外的变量 (蓝色框中的变量 int i = 0…)</p><p>局部变量：表示方法中的变量（红色框中的变量 String name…）</p><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230702154655305.png" alt="image-20230702154655305"></p><h3 id="Super方法的注意事项"><a class="header-anchor" href="#Super方法的注意事项">¶</a>Super方法的注意事项</h3><ol><li><p>super调用父类的构造方法，必须在构造方法的第一个.</p></li><li><p>super必须只能出现在子类的方法或者构造方法中.</p></li><li><p>super和this不能同时调用构造方法</p></li></ol><p><strong>Vs this:</strong></p><ul><li>​代表的对象不同：</li></ul><p>​this：本身调用者这个对象<br>​super：代表父类对象的应用</p><ul><li>​前提:</li></ul><p>​this：没哟继承也可以使用<br>​super：只能在继承条件才可以使用</p><ul><li>​构造方法:</li></ul><p>​this()：本类的构造<br>​super()：父类的构造！</p><h3 id="方法的重写"><a class="header-anchor" href="#方法的重写">¶</a>方法的重写</h3><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230502115713484.png" alt="image-20230502115713484"></p><p>需要有继承关系，子类重写父类的方法！</p><ol><li>方法名必须相同</li><li>参数列表必须相同</li><li>修饰符：范围可以扩大，但不能缩小：public &gt; protected &gt;default</li><li>抛出的异常：范围，可以被缩小，但不能扩大：Class Not Found Exception --&gt; Exception(大)</li></ol><p>==重写，子类的方法和父类必须要一致：方法体不同！==</p><p><strong>为什么要重写：</strong></p><ol><li>父类的功能，子类不一定需要，或者不一定满足！</li></ol><p>​<em>Alt + Insert ：override；</em></p><h3 id="多态"><a class="header-anchor" href="#多态">¶</a>多态</h3><hr><p><strong>多态是同一个行为具有多个不同表现形式或形态的能力。</strong></p><ol><li>多态是方法的多态，属性是没有多态的</li><li>父类和子类，有联系 类型转换异常！ClassCastException！</li><li>存在类型：继承关系，方法需要重写，父类引用指向子类对象！<em>Father f1 = new Son();</em></li></ol><p><strong>以下情况不可用多态</strong></p><ul><li>​<em>static</em>方法，属于类，它不属于实例</li><li>​<em>final</em>常量</li><li>​<em>private</em>方法</li></ul><h3 id="static关键字"><a class="header-anchor" href="#static关键字">¶</a>static关键字</h3><ul><li>静态变量</li></ul><p>#静态变量在类加载的时候初始化，不需要创建对象，内存就开辟了</p><p>#静态变量储存在方法区内存当中</p><ul><li>静态代码块</li></ul><p>#语法格式</p><p>​    <img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/download.png" alt="download"></p><p>#语法规则</p><p>**静态代码块在类加载的时候执行，并且只执行一次，==最早执行==，比main方法都早</p><p>***执行顺序：***静态 &gt; 匿名 &gt; 构造</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 第2输出</span></span><br><span class="line">{</span><br><span class="line">    System.out.println(<span class="string">"匿名代码块"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 第3输出</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">bank</span><span class="params">()</span>{</span><br><span class="line">    System.out.println(<span class="string">"构造方法"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 第1输出</span></span><br><span class="line"><span class="keyword">static</span> {</span><br><span class="line">    System.out.println(<span class="string">"静态代码块"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="抽象类"><a class="header-anchor" href="#抽象类">¶</a>抽象类</h3><p><strong>什么是抽象类？</strong><br>父类知道子类一定要完成某个功能，但是每个子类完成的情况是不一样的。子类以后也只会用自己重写的功能，那么父类的功能就可以定义为抽象方法，子类重写调用子类自己的就可以了。这个父类就成为抽象类。</p><p>**抽象方法：**没有方法体，只有方法签名，必须用abstract修饰。<br>拥有抽象方法的类必须定义成抽象类。</p><p>==abstract抽象类==</p><ol><li>不能new这个抽象类，只能靠子类去实现它：约束</li><li>抽象类中可以写普通方法</li><li>抽象方法必须在抽象类中</li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="comment">//一个类继承了抽象类，必须重写完抽象类的所有抽象方法，否则该类只能定义为抽象类。</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Employees</span>{</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employees</span>{</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> {</span><br><span class="line">System.out.println(<span class="string">"班主任要管理学生~~"</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">Employees</span>{</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> {</span><br><span class="line">System.out.println(<span class="string">"老师要教育学生~~"</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">//测试类：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractDemo</span> {</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"><span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">teacher.work();</span><br><span class="line"></span><br><span class="line"><span class="type">Manager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>();</span><br><span class="line">manager.work();</span><br><span class="line">} </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://blog.csdn.net/qq_54070103/article/details/124046117?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168372133616800215074688%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168372133616800215074688&amp;biz_id=0&amp;spm=1018.2226.3001.4187">写下这个</a></p><h1 id="类变量-class-variable"><a class="header-anchor" href="#类变量-class-variable">¶</a>类变量(class variable)</h1><h2 id="1-案例理解"><a class="header-anchor" href="#1-案例理解">¶</a>1.案例理解</h2><p>1.在main方法中定义一个变量count<br>2.当一个小孩加入游戏后count++,最后个count就记录有多少小孩玩游戏</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">a</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Child</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">"小明"</span>);</span><br><span class="line">        c1.join();</span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">        <span class="type">Child</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">"小李"</span>);</span><br><span class="line">        c2.join();</span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">        <span class="type">Child</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">"小天"</span>);</span><br><span class="line">        c3.join();</span><br><span class="line">        count++;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Child</span> <span class="variable">c4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">"小雪"</span>);</span><br><span class="line">        c4.join();</span><br><span class="line">        count++;</span><br><span class="line">        System.out.println(<span class="string">"共有"</span> + count + <span class="string">"个小孩加入"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> {</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Child</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> {</span><br><span class="line">System.out.println(name + <span class="string">"加入了游戏..."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>❓问题分析：<br>1.count是一个独立于对象，很尴尬<br>2.以后我们访问count很麻烦，没有使用到OOP<br>3.因此，我们引出类变量/静态变量</p><p>如果，设计一个int count表示总人数，我们在创建一个小孩时，就把count加1，并且count是==所有对像共享的就ok==了,我们使用类变量来解决ChildGame.java改进</p><p>将变量对所有对象共享</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">a</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Child</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">"小明"</span>);</span><br><span class="line">        c1.join();</span><br><span class="line"><span class="comment">//        count++;</span></span><br><span class="line">        c1.count++;</span><br><span class="line"></span><br><span class="line">        <span class="type">Child</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">"小李"</span>);</span><br><span class="line">        c2.join();</span><br><span class="line"><span class="comment">//        count++;</span></span><br><span class="line">        c2.count++;</span><br><span class="line"></span><br><span class="line">        <span class="type">Child</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">"小天"</span>);</span><br><span class="line">        c3.join();</span><br><span class="line"><span class="comment">//        count++;</span></span><br><span class="line">        c3.count++;</span><br><span class="line"></span><br><span class="line">        <span class="type">Child</span> <span class="variable">c4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">"小雪"</span>);</span><br><span class="line">        c4.join();</span><br><span class="line"><span class="comment">//        count++;</span></span><br><span class="line">        c4.count++;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"共有"</span> + Child.count + <span class="string">"个小孩加入"</span>);</span><br><span class="line">        <span class="comment">//  因为 Child 类共享count自增输出最终结果</span></span><br><span class="line">        System.out.println(c1.count);<span class="comment">// 4</span></span><br><span class="line">        System.out.println(c2.count);<span class="comment">// 4</span></span><br><span class="line">        System.out.println(c3.count);<span class="comment">// 4</span></span><br><span class="line">        System.out.println(c4.count);<span class="comment">// 4</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> {</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"><span class="comment">//定义一个变量 count,是一个类变量(静态变量)static 静态</span></span><br><span class="line"><span class="comment">//该对象最大的特点是会被Child 类的所有的对象实例共享</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Child</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(name + <span class="string">"加入了游戏..."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="概念"><a class="header-anchor" href="#概念">¶</a>概念</h2><ul><li>什么是类变量</li></ul><p>类变量也叫<strong>静态变量/静态属性</strong>，是该类的<strong>所有对象共享</strong>的变量，任何一个该类的对象去访问它时，取到的都是相同的值，同样任何一个该类的对象去修改它时，修改的也是同一个变量。这个从前面的图也可看出来。</p><ul><li>定义语法：</li></ul><p><code>访问修饰符</code> <code>static</code> <code>数据类型</code> <code>变量名</code>：[推荐]<br><code>static</code> <code>访问修饰符``数据类型</code> <code>变量名</code>；</p><ul><li>如何访问</li></ul><p><code>类名</code> <code>.</code> <code>类变量名</code>;[推荐]</p><p><code>对象名</code> <code>.</code> <code>类变量名</code>;</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">b</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">      System.out.println(C.name);</span><br><span class="line"></span><br><span class="line">      <span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">      System.out.println(c.name);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> {</span><br><span class="line">    <span class="comment">// 类变量</span></span><br><span class="line"><span class="comment">//    static public String name = "小明";</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">"小明"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="类方法"><a class="header-anchor" href="#类方法">¶</a>类方法</h2><p>类方法经典的使用场景<br>当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率。</p><p>比如：工具类中的方法utis<br>Math类、Arrays类、Collections集合类看下源码：</p><p>在程序员实际开发，往往会将一些通用的方法，设计成静态方法，这样我们不需要创建对象就可以使用<br>了，比如打印一维数组，冒泡排序，完成谋个计算任务等.[举例说明]</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> n1 , <span class="type">int</span> )</span> {</span><br><span class="line"><span class="keyword">return</span> n1 + n2;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">c</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        D.hi();</span><br><span class="line">        D.say();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> {<span class="comment">//非静态方法，普通方法</span></span><br><span class="line"><span class="comment">//        类方法中不允许使用和对象有关的关键字</span></span><br><span class="line"><span class="comment">//        比如this和super</span></span><br><span class="line">        System.out.println(<span class="string">"ohhhhh"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> {<span class="comment">//静态方法，类方法</span></span><br><span class="line"><span class="comment">//        类方法(静态方法)中 只能访问 静态变量 或静态方法</span></span><br><span class="line">        System.out.println(<span class="string">"hi!!!"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>🫠<strong>小结</strong>：静态方法，只能访问<code>静态的成员</code>，非静态的方法，可以访问<code>静态成员</code>和<code>非静态成员</code></p><h1 id="代码块"><a class="header-anchor" href="#代码块">¶</a>代码块</h1><h2 id="1-基本介绍"><a class="header-anchor" href="#1-基本介绍">¶</a>1.基本介绍</h2><p>代码化块又称为初始化块，属于类中的成员[即是类的一部分]，类似于方法，将逻辑语句封装在方法体中，通过{}包围起来。但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显式调用，而是加载类时，或创建对象时隐式调用。</p><h2 id="2-代码块的好处和案例演示"><a class="header-anchor" href="#2-代码块的好处和案例演示">¶</a>2.代码块的好处和案例演示</h2><p>1)相当于另外一种形式的构造器（对构造器的补充机制），可以做初始化的操作<br>2)场景：如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的重用性</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">code01</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Movie</span> <span class="variable">movie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Movie</span>(<span class="string">"闪电侠"</span>);</span><br><span class="line">        <span class="type">Movie</span> <span class="variable">movie1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Movie</span>(<span class="string">"唐人街探案"</span> , <span class="number">100</span> , <span class="string">"陈思诚"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Movie</span> {</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line">    <span class="keyword">private</span> String director;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="comment">//(1)下面的三个构造器都有相同的语句</span></span><br><span class="line">    <span class="comment">//(2)这样代码看起来比较冗余</span></span><br><span class="line">    <span class="comment">//(3)这时我们可以把相同的语句，放入到一个代码块中，即可</span></span><br><span class="line">    <span class="comment">//(4)这样当我们不管调用哪个构造器,创建对象,都会先调用代码块的内容</span></span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line">        System.out.println(<span class="string">"电影屏幕打开.."</span>);</span><br><span class="line">        System.out.println(<span class="string">"广告开始.·."</span>);</span><br><span class="line">        System.out.println(<span class="string">"电影正是开始.."</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Movie</span><span class="params">(String name)</span> {</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        System.out.println("电影屏幕打开..");</span></span><br><span class="line"><span class="comment">        System.out.println("广告开始.·.");</span></span><br><span class="line"><span class="comment">        System.out.println("电影正是开始..");</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Movie</span><span class="params">(String name, <span class="type">double</span> price)</span> {</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        System.out.println("电影屏幕打开..");</span></span><br><span class="line"><span class="comment">        System.out.println("广告开始.·.");</span></span><br><span class="line"><span class="comment">        System.out.println("电影正是开始..");</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Movie</span><span class="params">(String name, <span class="type">double</span> price, String director)</span> {</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        System.out.println("电影屏幕打开..");</span></span><br><span class="line"><span class="comment">        System.out.println("广告开始.·.");</span></span><br><span class="line"><span class="comment">        System.out.println("电影正是开始..");</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">        <span class="built_in">this</span>.director = director;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="3-静态代码块"><a class="header-anchor" href="#3-静态代码块">¶</a>3.静态代码块</h2><p>static代码块也叫<code>静态代码块</code>，作用就是对类进行初始化，而且它随着<code>类的加载</code>而执行，并且<br>只会执行一次。如果是普通代码块，每创建一个对象，就执行。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>类什么时候被加载[重要]👍</p><ol><li>创建对象实例时(new)</li><li>创建子类对象实例，父类也会被加载</li><li>使用类的静态成员时（静态属性，静态方法）</li><li>普通的代码块，在创建对象实例时，会被隐式的调用。<br>被==创建==一次，就会==调用==一次。</li><li>如果只是使用类的静态成员时，普通代码块并不会执行</li></ol><p>案例演示：A类extends B类的静态块</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 1.创建对象实例时(new)</span></span><br><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line">    System.out.println(<span class="string">"AAAAAAAAAAAAA"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//输出 AAAAAAAAAAAAAAAAA</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 2.创建子类对象实例，父类也会被加载</span></span><br><span class="line"><span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line">     <span class="keyword">static</span> {</span><br><span class="line">        System.out.println(<span class="string">"AAAAAAAAAAAAA"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> {</span><br><span class="line">     <span class="keyword">static</span> {</span><br><span class="line">        System.out.println(<span class="string">"BBBBBBBBBBBBBBB"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">AAAAAAAAAAAAA</span></span><br><span class="line"><span class="comment">BBBBBBBBBBBBBBB</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><p>若父类此时为非静态代码块，则优先输出<code>子类</code></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 如果只是使用类的静态成员时，普通代码块并不会执行</span></span><br><span class="line"></span><br><span class="line">System.out.println(B.t);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line">      {</span><br><span class="line">        System.out.println(<span class="string">"AAAAAAAAAAAAA"</span>);</span><br><span class="line">      } <span class="comment">// 普通代码块不会执行</span></span><br><span class="line">      <span class="keyword">static</span> {</span><br><span class="line">          System.out.println(<span class="string">"A的静态代码块"</span>);</span><br><span class="line">      }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">8888</span>;</span><br><span class="line">    {</span><br><span class="line">        System.out.println(<span class="string">"B的普通代码块"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"111111111111"</span>);</span><br><span class="line">    }</span><br><span class="line">     <span class="keyword">static</span>  {</span><br><span class="line">        System.out.println(<span class="string">"BBBBBBBBBBBBBBB"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*输出</span></span><br><span class="line"><span class="comment">A的静态代码块</span></span><br><span class="line"><span class="comment">BBBBBBBBBBBBBBB</span></span><br><span class="line"><span class="comment">8888</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="4-代码块的调用⭐"><a class="header-anchor" href="#4-代码块的调用⭐">¶</a>4.代码块的调用⭐</h2><p>4)创建一个对象时，在一个类<strong>调用顺序</strong>是：（重点，难点）：</p><ol><li>调用静态代码块和静态属性初始化（注意：静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用)[举例说明]</li><li>调用普通代码块和蔷通属性的初始化（注意：普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按定义顺序调用)</li><li>调用构造方法。</li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> codeBlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">code04</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">V</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">S</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">S</span><span class="params">()</span>{</span><br><span class="line">        System.out.println(<span class="string">"S的无参构造器"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">V</span> <span class="keyword">extends</span> <span class="title class_">S</span>{</span><br><span class="line">    {</span><br><span class="line">        System.out.println(<span class="string">"V的普通代码块"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">V</span><span class="params">()</span>{</span><br><span class="line">        System.out.println(<span class="string">"V的无参构造器"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">S的无参构造器</span></span><br><span class="line"><span class="comment">V的普通代码块</span></span><br><span class="line"><span class="comment">V的无参构造器</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><p>🤯<strong>父类静态-&gt;子类静态-&gt;父类普通-&gt;父类构造器-&gt;子类普通-&gt;子类构造器</strong>🤯==[面试题]==</p><h1 id="抽象类（abstract）"><a class="header-anchor" href="#抽象类（abstract）">¶</a>抽象类（abstract）</h1><ul><li>所谓抽象方法就是没有实现的方法</li><li>所谓没有实现就是指，没有方法体</li><li>当一个类中存在抽象方法时，需要将该类声明为abstract类</li><li>一般来说，抽象类会被继承，有其子类来实现抽象方法</li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> {</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里eat 实现了，其实没有什么意义</span></span><br><span class="line">    <span class="comment">// 即： 父类方法不确定的问题</span></span><br><span class="line">    <span class="comment">// 将该方法设计为抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>使用场景更多应用于 <code>设计模式</code></p><ul><li>抽象类不能被实例化[举例]</li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">A</span>(); <span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span>() { <span class="comment">//抽象类</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>抽象类不一定要包含abstract方法。也就是说，抽象类可以没有abstract方法[举例]</li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> {</span><br><span class="line">System.out.print(<span class="string">"hi"</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>abstract只能修饰类和方法，不能修饰属性和其它的</li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span>() {</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="variable">ni</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 报错</span></span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//抽象类的本质还是类，所以可以有类的各种成员</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">D</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">"小红"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"hi"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">ok</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"ok"</span>);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract类</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">E</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">F</span> <span class="keyword">extends</span> <span class="title class_">E</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> { <span class="comment">//这里相等于G子类实现了父类E的抽象方法，所谓实现方法，就是有方法体</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//抽象方法不能使用private、final和static来修饰，因为这些关键字都是和重写相违背的</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">H</span> {</span><br><span class="line"><span class="comment">//    private abstract void hi();</span></span><br><span class="line"><span class="comment">//    public final abstract int n = 100;</span></span><br><span class="line"><span class="comment">//    public static abstract void hi();</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><em><strong>继承时，只有父类需要是抽象，子类无需标记abstract，否则main类对象无法实例化</strong></em></p><h1 id="设计模式"><a class="header-anchor" href="#设计模式">¶</a>设计模式</h1><p><em>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案</em></p><p>总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。当然，我们还会讨论另一类设计模式：J2EE 设计模式。</p><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230713173936793.png" alt="image-20230713173936793"></p><h2 id="1-单例模式"><a class="header-anchor" href="#1-单例模式">¶</a>1.单例模式</h2><p>所谓类的<em><strong>单例设计模式</strong></em>，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法</p><p>单例模式分为两种：</p><ul><li>饿汉式</li><li>懒汉式</li></ul><h3 id="饿汉式"><a class="header-anchor" href="#饿汉式">¶</a>饿汉式</h3><p>步骤如下：</p><ol><li>构造器私有化=》防止直接new</li><li>类的内部创建对象</li><li>向外暴露一个静态的公共方法getInstance。</li><li>代码实现</li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hungry</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"><span class="comment">//        GirlFriend xh = new GirlFriend("小红");</span></span><br><span class="line"><span class="comment">//        GirlFriend xb = new GirlFriend("小白");</span></span><br><span class="line">        <span class="type">GirlFriend</span> <span class="variable">gf</span> <span class="operator">=</span> GirlFriend.getInstance();</span><br><span class="line">        System.out.println(gf);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 有一个类</span></span><br><span class="line"><span class="comment">// 只能有一个女朋友</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GirlFriend</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">GirlFriend</span> <span class="variable">gf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GirlFriend</span>(<span class="string">"小"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 构造器私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">GirlFriend</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"><span class="comment">//向外暴露一个静态的公共方法getInstance</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GirlFriend <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> gf;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"GirlFriend{"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="接口"><a class="header-anchor" href="#接口">¶</a>接口</h1><h2 id="1-基本概念"><a class="header-anchor" href="#1-基本概念">¶</a>1.基本概念</h2><ul><li>普通类：只有具体实现</li><li>抽象类：具体实现和规范（抽象方法）都有！</li><li>接口：只有规范！自己无法写方法专业的约束！约束和实现分离：面向接口编程~</li></ul><p><code>interface</code>定义的关键字，接口都需要右实现类</p><p>==注意：==</p><ol><li>接口不能被实例化</li><li>接口中的所有定义的方法其实都是抽象的<code>public abstract</code>,故不需要写<code>abstract</code>,即可表示抽象类</li><li>一个普通类实现接口，就必须将该接口的所有方法都实现</li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span>  <span class="title class_">A</span> {<span class="comment">//用interface定义</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String name)</span>;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">delate</span><span class="params">(String name)</span>;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String name)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">A</span> {<span class="comment">//再用implements实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String name)</span> {</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delate</span><span class="params">(String name)</span> {</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String name)</span> {</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="2-快速入门"><a class="header-anchor" href="#2-快速入门">¶</a>2.快速入门</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//  ========1========</span></span><br><span class="line"><span class="comment">//建立一个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">USB</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//========2========</span></span><br><span class="line"><span class="comment">//电脑类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">(USB phone)</span>{<span class="comment">//电脑通过接口连接手机</span></span><br><span class="line">        phone.start();</span><br><span class="line">        phone.stop();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work2</span><span class="params">(USB camera)</span>{<span class="comment">//电脑通过接口连接相机</span></span><br><span class="line">        camera.start();</span><br><span class="line">        camera.stop();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//========3========</span></span><br><span class="line"><span class="comment">//手机类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> <span class="keyword">implements</span> <span class="title class_">USB</span>{<span class="comment">//手机连接接口</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"手机开始工作"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"手机停止工作"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//  ========4========</span></span><br><span class="line"><span class="comment">//相机类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Camera</span> <span class="keyword">implements</span> <span class="title class_">USB</span>{<span class="comment">//相机连接接口</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"相机开始工作"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"相机停止工作"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//========5========</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"><span class="comment">//        创建相机类 和 手机类</span></span><br><span class="line">        <span class="type">Camera</span> <span class="variable">camera</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Camera</span>();</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line"><span class="comment">//        创建电脑类 ，用相机 和 手机连接电脑</span></span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        System.out.println(<span class="string">"========"</span>);</span><br><span class="line">        computer.work(phone);</span><br><span class="line">        computer.work2(camera);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="3-接口的使用细节"><a class="header-anchor" href="#3-接口的使用细节">¶</a>3.接口的使用细节</h2><p>实现方法的快捷键 <code>Ctrl + I</code> 来解决</p><ul><li>抽象类实现接口,可以不用实现接口的方法</li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">B</span> {<span class="comment">// 报错,因为普通类实现接口要,将方法实现</span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ======================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">B</span> {<span class="comment">// 抽象类实现接口,可以不用实现接口的方法</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>一个接口不能继承其他类,但是可以继承多个别的接口</li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">B</span>,C,D{}</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">B</span>,C,D{}</span><br></pre></td></tr></tbody></table></figure><ul><li>接口中的属性,只能是final,而且是 ==public static final== 修饰符</li></ul><h2 id="接口-VS-继承"><a class="header-anchor" href="#接口-VS-继承">¶</a>接口 VS 继承</h2><p>接口相当于是继承的<strong>补充</strong>和<strong>多继承</strong></p><blockquote><ul><li>接口和继承解决的问题不同</li><li>继承的价值主要在于：解决代码的<strong>复用性</strong>和<strong>可维护性</strong>。</li><li>接口的价值主要在手：设计，设计好各种规范（方法），让其它类去实现这些方法。</li></ul></blockquote><blockquote><ul><li>接口比继承更加灵活</li><li>接口比继承更加灵活，继承是满足is-a的关系，而接口只需满足ke-a的关系</li><li>接口在一定程度上实现代码解耦[即：接口规范性+动态绑定机制]</li></ul></blockquote><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">duotai</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        Usb_[] usbs = <span class="keyword">new</span> <span class="title class_">Usb_</span>[<span class="number">2</span>];</span><br><span class="line">        usbs[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">iPhone</span>();</span><br><span class="line">        usbs[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Com</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; usbs.length; i++) {</span><br><span class="line">            usbs[i].work_();</span><br><span class="line">            <span class="keyword">if</span> (usbs[i] <span class="keyword">instanceof</span> iPhone) {</span><br><span class="line">                ((iPhone) usbs[i]).call();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Usb_</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">work_</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">iPhone</span> <span class="keyword">implements</span> <span class="title class_">Usb_</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work_</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"工作中"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"打电话"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Com</span> <span class="keyword">implements</span> <span class="title class_">Usb_</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work_</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"拍照"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="重载（OverLoad）"><a class="header-anchor" href="#重载（OverLoad）">¶</a>重载（OverLoad）</h1><p>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</p><ul><li>被重载的方法必须改变参数列表(参数个数或类型不一样)；</li><li>被重载的方法可以改变返回类型；</li><li>被重载的方法可以改变访问修饰符；</li><li>被重载的方法可以声明新的或更广的检查异常；</li><li>方法能够在同一个类中或者在一个子类中被重载。</li><li>无法以返回值类型作为重载函数的区分标准。</li></ul><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230705134253254-1688535777146-1.png" alt="image-20230705134253254"></p><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230705134342431.png" alt="image-20230705134342431"></p><h1 id="作用域（Scope）"><a class="header-anchor" href="#作用域（Scope）">¶</a>作用域（Scope）</h1><p>面向对象中，变量作用域是非常重要知识点，相对来说不是特别好理解</p><p>1.在java编程中，主要的变量就是属性（成员变量）和局部变量。<br>2.我们说的局部变量一般是指在成员方法中定义的变量。【举例Cat类：cry】<br>3.java中作用域的分类<br>全局变量：也就是属性，作用域为整个类体Cat类：cry eat等方法使用属性【举例】<br>局部变量：也就是除了属性之外的其他变量，作用域为定义它的代码块中！<br>4.<strong>全局变量（属性）可以不赋值</strong>，直接使用，因为有默认值，<strong>局部变量必须赋值后</strong>，才能使用，因为没有默认值。[举例]</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Scope</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> {</span><br><span class="line">    <span class="comment">//全局变量：也就是属性，作用域为整个类体Cat类：cry eat等方法使用属性</span></span><br><span class="line">    <span class="comment">//属性在定义时，可以直接赋值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> {</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1·局部变量一般是指在成员方法中定义的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.n和name就是局部变量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.n和name的作用域在cry方法中</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">"jake"</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>{</span><br><span class="line">        System.out.println(age);<span class="comment">// 用的是全局变量的,可以使用</span></span><br><span class="line"><span class="comment">//      System.out.println(name); 用的是say()方法中的局部变量,不可使用</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Scope</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Person_1</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person_1</span>();</span><br><span class="line">        p1.say();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person_1</span> {</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">"jack"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">//属性和局部变量可以重名，访问时遵循就近原则</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">"king"</span>;</span><br><span class="line">        System.out.println(<span class="string">"say() name="</span> + name);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="构造器"><a class="header-anchor" href="#构造器">¶</a>构造器</h1><p>我们来看一个需求：前面我们在创建人类的对象时，是先把一个对象创建好后，再给他的年龄和姓名属性赋值，如果现在我要求，在创建人类的对象时，就直接指定这个对象的年龄和姓名，该怎么做？这时就可以使用构造器。</p><p><strong>基本介绍</strong><br>构造方法又叫==构造器(constructor)==,是类的一种特殊的方法，<br>它的主要作用是<br>完成对新对象的初始化。它有几个特点：</p><ol><li>方法名和类名相同</li><li>没有返回值</li><li>在创建对象时，系统会自动的调用该类的构造器完成对象的初始化。</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">//无参构造器</span><br><span class="line">public A() {}</span><br><span class="line"></span><br><span class="line">//构造器</span><br><span class="line">public A(String n1 ,int n2) {}</span><br></pre></td></tr></tbody></table></figure><p>==注意==：</p><p>1)构造器的修饰符可以默认，也可以是public protected private<br>2)构造器没有返回值<br>3)方法名和类名字必须一样<br>4)参数列表和成员方法一样的规则<br>5)构造器的调用，由系统完成</p><h1 id="HashCode方法"><a class="header-anchor" href="#HashCode方法">¶</a>HashCode方法</h1><p>1)提高具有哈希结构的容器的效率！<br>2)两个引用，如果指向的是同一个对象，则哈希值肯定是一样的！<br>3)两个引用，如果指向的是不同对象，则哈希值是不一样的<br>4)哈希值主要根据地址号来的！，不能完全将哈希值等价于地址。<br>5)案例演示[HashCode_java]:obj.hashCode(0[测试：Aobj1=new A():Aobj2=newA0;A<br>obj3 obj1]<br>6)后面在集合，中hashCode如果需要的话，也会重写</p><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230624111341058.png" alt="image-20230624111341058"></p><h1 id="toString方法"><a class="header-anchor" href="#toString方法">¶</a>toString方法</h1><p><strong>基本介绍</strong><br>默认返回：全类名+@+哈希值的十六进制，【查看Object的toString.方法】<br>子类往往重写toString方法，用于返回对象的属性信息</p><p>//重写tostring方法，输出对象的属性<br>//使用快捷键即可alt+insert-&gt;toString</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line"><span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hasCode());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">System.out.print(d); <span class="comment">//等价 d.toString()</span></span><br></pre></td></tr></tbody></table></figure><h1 id="内部类"><a class="header-anchor" href="#内部类">¶</a>内部类</h1><hr><p>一个类的内部又完整的嵌套了另一个类结构。披嵌套的类称归内部类（inner class)嵌套其他类的类称为外部类(outer cl5S)。是我们类的第五大成员【思考：类的五大成员是哪些[]】，内部黄最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系。</p><p>类的五大成员：</p><ul><li>属性</li><li>方法</li><li>代码块</li><li>构造器</li><li>内部类</li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> {<span class="comment">//外部类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">inner</span>{}<span class="comment">//内部类</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">outer</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>  <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Outer</span><span class="params">(<span class="type">int</span> n1)</span> {<span class="comment">//构造器</span></span><br><span class="line">        <span class="built_in">this</span>.n1 = n1;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> {      <span class="comment">//方法</span></span><br><span class="line">        System.out.println(<span class="string">"mi()"</span>);</span><br><span class="line">    }</span><br><span class="line">    {                       <span class="comment">//代码块</span></span><br><span class="line">        System.out.println(<span class="string">"代码块..."</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> {           <span class="comment">//内部类</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>🤷‍♂️定义在外部类局部位置上（比如方法内）：<br>1)局部内部类（有类名）<br>2)匿名内部类（没有类名，重点！！！）<br>🤷‍♀️定义在外部类的成员位置上：<br>1)成员内部类（没用static修饰）<br>2)静态内部类（使用static修饰）</p><h2 id="局部内部类"><a class="header-anchor" href="#局部内部类">¶</a>局部内部类</h2><ol><li>局部内部类是定义在外部类的局部位置，通常在方法</li><li>可以直接访问外部类的所有成员，包括私有的</li><li>不能添加访问修饰符，但是可以使用final修饰</li><li>作用域：仅仅在定义它的==方法==或==代码块==中</li><li>局部内部类可以直接访问外部类的成员，比如下面外部类1和m2()</li><li>如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，</li></ol><hr><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">jubu</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">outer</span>();</span><br><span class="line">        outer.m1();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">outer</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Outer m2()"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> {<span class="comment">//方法</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Inner02</span> { <span class="comment">//局部内部类</span></span><br><span class="line">            <span class="comment">// 2.可以直接访问外部类的所有成员，包括私有的</span></span><br><span class="line">            <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> {</span><br><span class="line">                System.out.println(<span class="string">"n="</span> + n + <span class="string">"外部类n1"</span> +  outer.<span class="built_in">this</span>.n); <span class="comment">//重名</span></span><br><span class="line">                m2();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Inner02</span> <span class="variable">inner02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner02</span>();</span><br><span class="line">        inner02.f1();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="匿名内部类"><a class="header-anchor" href="#匿名内部类">¶</a>匿名内部类</h2><p>本质还是类内部类这个类没有名字同时还是一个对象</p><ol><li>外部其他类–不能访问–一&gt;匿名内部类（因为匿名内部类地位是一个局部变量）</li><li>如果外部类和匿名内部类的成员重名时，匿名内部类访问的话，默认遵循就近原则<br>如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问</li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Anonymous</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Outer02</span> <span class="variable">outer02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer02</span>();</span><br><span class="line">        outer02.method();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer02</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>{   <span class="comment">//方法</span></span><br><span class="line">        <span class="comment">//基于接口的匿名内部类</span></span><br><span class="line">        <span class="comment">//1.需求：想使用IA接口，并创建对象</span></span><br><span class="line">        <span class="comment">//2,传统方式，是写一个类，实现该接口，并创建对象</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">tiger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> {</span><br><span class="line">                System.out.println(<span class="string">"老虎"</span>);</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">        tiger.cry();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        A tiger = new Tiger();</span></span><br><span class="line"><span class="comment">//        tiger.cry();</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> {   <span class="comment">//接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//class Tiger implements A {      //传统方法</span></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public void cry() {</span></span><br><span class="line"><span class="comment">//        System.out.println("qqqqqqqqq");</span></span><br><span class="line"><span class="comment">//    }</span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//class Dog implements A {</span></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public void cry() {</span></span><br><span class="line"><span class="comment">//        System.out.println("ppppppppppp");</span></span><br><span class="line"><span class="comment">//    }</span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> {  <span class="comment">//类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">(String name)</span> {    <span class="comment">//构造器</span></span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> {      <span class="comment">//方法</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="使用细节"><a class="header-anchor" href="#使用细节">¶</a>使用细节</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Anonymous02</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">X</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">X</span>();</span><br><span class="line">        x.fi();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">99</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fi</span><span class="params">()</span> { <span class="comment">//方法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 内部类在方法中使用</span></span><br><span class="line">        <span class="comment">// 创建一个基于类的匿名内部类</span></span><br><span class="line">        <span class="comment">// 匿名内部类两种使用方法</span></span><br><span class="line">        <span class="comment">// 1.new一个类，随后调用😉</span></span><br><span class="line">        <span class="type">Z</span> <span class="variable">z</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Z</span>(<span class="string">"jack"</span>) {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> {</span><br><span class="line">                <span class="built_in">super</span>.hi();</span><br><span class="line">                System.out.println(i);<span class="comment">//返回10</span></span><br><span class="line">                System.out.println(X.<span class="built_in">this</span>.i);<span class="comment">//返回99</span></span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">        z.hi();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2.直接当对象使用🤯</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Z</span>(<span class="string">"pipi"</span>) {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> {</span><br><span class="line">                <span class="built_in">super</span>.hi();</span><br><span class="line">            }</span><br><span class="line">        }.hi();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Z</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Z</span><span class="params">(String name)</span> {</span><br><span class="line">        System.out.println(<span class="string">"bbbbbbbbbb"</span> + name);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"hi"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="成员内部类"><a class="header-anchor" href="#成员内部类">¶</a>成员内部类</h2><p>成员内部类是定义在外部类的成员位置，并且没有static修饰</p><p>成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。<strong>创建成员内部类</strong>对象的一般方式如下：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  {</span><br><span class="line">        <span class="comment">//第一种方式：</span></span><br><span class="line">        <span class="type">Outter</span> <span class="variable">outter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outter</span>();</span><br><span class="line">        Outter.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outter.<span class="keyword">new</span> <span class="title class_">Inner</span>();  <span class="comment">//必须通过Outter对象来创建</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//第二种方式：</span></span><br><span class="line">        Outter.<span class="type">Inner</span> <span class="variable">inner1</span> <span class="operator">=</span> outter.getInnerInstance();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outter</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Outter</span><span class="params">()</span> {</span><br><span class="line">         </span><br><span class="line">    }</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInnerInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span>(inner == <span class="literal">null</span>)</span><br><span class="line">            inner = <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        <span class="keyword">return</span> inner;</span><br><span class="line">    }</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> {</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Inner</span><span class="params">()</span> {</span><br><span class="line">             </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol><li>成员内部类–访问–&gt;外部类（比如：属性)[]（说明）</li><li>外部类–访问–&gt;成员内部类（说明）访问方式：创建对象，再访问</li><li>外部其他类–访问–&gt;成员内部类</li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemberInner</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        b.tic();</span><br><span class="line"></span><br><span class="line">        B.<span class="type">BI</span> <span class="variable">bi</span> <span class="operator">=</span> b.<span class="keyword">new</span> <span class="title class_">BI</span>();</span><br><span class="line">        System.out.println(bi.t);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BI</span> {<span class="comment">// 成员内部类</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> {</span><br><span class="line"><span class="comment">//          成员内部类--访问--&gt;外部类(访问方式：直接访问)</span></span><br><span class="line">            System.out.println(i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tic</span><span class="params">()</span> {</span><br><span class="line"><span class="comment">//      外部类--访问--&gt;成员内部类（说明）访问方式：创建对象，再访问</span></span><br><span class="line"><span class="comment">//        BI bi = new BI();</span></span><br><span class="line"><span class="comment">//        bi.say();</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="静态内部类"><a class="header-anchor" href="#静态内部类">¶</a>静态内部类</h2><p>说明：静态内部类是定义在外部类的成员位置，并且有static修饰</p><ol><li>可以<strong>直接访问</strong>外部类的<strong>所有</strong>静态成员，包含私有的，但不能直接访问非静态成员</li><li>可以添加任意访问修饰符(public、protected、默认、private),因为它的地位就是一个成员。</li><li>作用域：同其他的成员，为整个类体</li><li>如果外部类和静态内部类的成员重名时，静态内部类访问的时，默认遵循就近原则，如果想访问外部类的成员，则可以使用(外部类成员)去访问</li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">staticInner</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Outer01</span> <span class="variable">outer01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer01</span>();</span><br><span class="line">        outer01.tic();</span><br><span class="line">        </span><br><span class="line">        Outer01.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer01</span>.Inner();</span><br><span class="line">        System.out.println(inner.i);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer01</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">"张三"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span> {</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> {</span><br><span class="line"><span class="comment">//      4.静态内部类--访问--&gt;外部类（比如：静态属性)[访问方式：直接访问所有静 态成员]</span></span><br><span class="line"></span><br><span class="line">            System.out.println(name);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tic</span><span class="params">()</span> {</span><br><span class="line"><span class="comment">//      5.外部类--访问---&gt;静态内部类访问方式：创建对象，再访问</span></span><br><span class="line">        <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        System.out.println(inner.i);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="枚举类（Enum）"><a class="header-anchor" href="#枚举类（Enum）">¶</a>枚举类（Enum）</h1><p>Java 枚举是一个特殊的类，一般表示一组常量，比如一年的 4 个季节，一年的 12 个月份，一个星期的 7 天，方向有东南西北等。将一个一个具体的类列出来。</p><p>Java 枚举类使用 enum 关键字来定义，各个常量使用逗号 <strong>,</strong> 来分割。</p><h2 id="自定义类实现枚举"><a class="header-anchor" href="#自定义类实现枚举">¶</a>自定义类实现枚举</h2><ul><li>不需要提供setXxx方法，因为枚举对象值通常为只读</li><li>对枚举对象/属性使用final+static共同修饰，实现底层优化.</li><li>枚举对象名通常使用全部大写，常量的命名规范</li><li>枚举对象根据需要，也可以有多个属性</li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> enumclass;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @author 徐永豪</span></span><br><span class="line"><span class="comment"> * @version 1.0</span></span><br><span class="line"><span class="comment"> * 2023/7/23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">code01</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(Season.AUTUMN);</span><br><span class="line">        System.out.println(Season.WINTER);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 自定义枚举类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span> {</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"><span class="comment">// 3.在Season的内部,直接创建固定的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">"冬天"</span>,<span class="string">"寒冷"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">"春天"</span>,<span class="string">"温暖"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">"夏天"</span>,<span class="string">"炎热"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">"秋天"</span>,<span class="string">"凉爽"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">OTHER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">"白天"</span>,<span class="string">"明亮"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  1.将构造器私有化,目的防止直接new</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name, String desc)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.删去set方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Season{"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", desc='"</span> + desc + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果使用了enum来实现枚举类</p><ol><li>使用关键字enum替代class</li><li>public static final Season SPRING=new Season(“春天”，“温暖”)直接使用SPRING(“春天”，"温暖、解读常量名（实参列表）</li><li>如果有多个常量（对象），使用，号间隔即可</li><li>如果使用enum来实现枚举，要求将定义常量对象，写在前面</li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Season02</span> {</span><br><span class="line">    WINTER(<span class="string">"冬天"</span>,<span class="string">"寒冷"</span>),SPRING(<span class="string">"春天"</span>,<span class="string">"温暖"</span>),</span><br><span class="line">    SUMMER(<span class="string">"夏天"</span>,<span class="string">"炎热"</span>),AUTUMN(<span class="string">"秋天"</span>,<span class="string">"凉爽"</span>),</span><br><span class="line">    OTHER(<span class="string">"白天"</span>,<span class="string">"明亮"</span>);</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">    <span class="comment">// 3.在Season的内部,直接创建固定的对象</span></span><br><span class="line"><span class="comment">//    public static final Season WINTER = new Season("冬天","寒冷");</span></span><br><span class="line"><span class="comment">//    public static final Season SPRING = new Season("春天","温暖");</span></span><br><span class="line"><span class="comment">//    public static final Season SUMMER = new Season("夏天","炎热");</span></span><br><span class="line"><span class="comment">//    public static final Season AUTUMN = new Season("秋天","凉爽");</span></span><br><span class="line"><span class="comment">//    public static final Season OTHER = new Season("白天","明亮");</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  1.将构造器私有化,目的防止直接new</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season02</span><span class="params">(String name, String desc)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.删去set方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Season02{"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", desc='"</span> + desc + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="enum常用方法"><a class="header-anchor" href="#enum常用方法">¶</a>enum常用方法</h2><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230726135853880-1690351152039-1.png" alt="image-20230726135853880"></p><p>还有一个<em><strong>values方法</strong></em>，可以将<a href="https://so.csdn.net/so/search?q=%E6%9E%9A%E4%B8%BE%E7%B1%BB&amp;spm=1001.2101.3001.7020">枚举类</a>转变为一个枚举类型的数组，因为枚举中没有下标，我们没有办法通过下标来快速找到需要的枚举类，这时候，转变为数组之后，我们就可以通过数组的下标，来找到我们需要的枚举类</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">code03</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Season02</span> <span class="variable">autumn</span> <span class="operator">=</span> Season02.AUTUMN;</span><br><span class="line"><span class="comment">//      输出枚举对象的名字</span></span><br><span class="line">        System.out.println(autumn.name());</span><br><span class="line"><span class="comment">//      ordinal()输出的是该枚举对象的次序/编号，从0开始编号</span></span><br><span class="line"><span class="comment">//      AUTUMN枚举对象是第三个，因此输出2</span></span><br><span class="line">        System.out.println(autumn.ordinal());</span><br><span class="line"><span class="comment">//        Season[] values = Season02.values();</span></span><br><span class="line"><span class="comment">//        for (Season02 season : values) {</span></span><br><span class="line"><span class="comment">//            //增强for循环</span></span><br><span class="line"><span class="comment">//        }</span></span><br><span class="line">        <span class="type">int</span>[] nums = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">9</span>};</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">            System.out.print(nums[i] + <span class="string">"\t"</span>);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"=======增强for======="</span>);</span><br><span class="line"><span class="comment">//      执行流程是依次从nums数组中取出数据，赋给i，如果取出完毕，则退出for</span></span><br><span class="line"><span class="comment">//      for (int i : nums)</span></span><br><span class="line">        <span class="keyword">for</span>(Season02 season02 : Season02.values()) {</span><br><span class="line">            System.out.println(season02);</span><br><span class="line">        }</span><br><span class="line"><span class="comment">//      value0f:将字符串转换成枚举对象，要求字符串必须VT为已有的常量名，否则报异常</span></span><br><span class="line">        <span class="type">Season02</span> <span class="variable">aut</span> <span class="operator">=</span> Season02.valueOf(<span class="string">"AUTUMN"</span>);</span><br><span class="line">        System.out.println(<span class="string">"AUT"</span> + aut);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="案例"><a class="header-anchor" href="#案例">¶</a>案例</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1)声明Week枚举类，其中包含星期一至星期日的定义；</span></span><br><span class="line"><span class="comment">MONDAY TUESDAY,WEDNESDAY,THURSDAY,</span></span><br><span class="line"><span class="comment">FRIDAY,SATURDAY,SUNDAY;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2)使用values返回所有的枚举数组，并遍历，输出左图</span></span><br><span class="line"><span class="comment">===所有星期的信息如下==</span></span><br><span class="line"><span class="comment">    星期一</span></span><br><span class="line"><span class="comment">    星期二</span></span><br><span class="line"><span class="comment">    星期三</span></span><br><span class="line"><span class="comment">    星期四</span></span><br><span class="line"><span class="comment">    星期五</span></span><br><span class="line"><span class="comment">    星期六</span></span><br><span class="line"><span class="comment">    星期日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">exercise</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        Week[] value = Week.values();</span><br><span class="line">        System.out.println(<span class="string">"===所有星期的信息如下=="</span>);</span><br><span class="line">        <span class="keyword">for</span> (Week week : value) {</span><br><span class="line">            System.out.println(week);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Week</span> {</span><br><span class="line">    MONDAY(<span class="string">"星期一"</span>),TUESDAY(<span class="string">"星期二"</span>),WEDNESDAY(<span class="string">"星期三"</span>),</span><br><span class="line">    THURSDAY(<span class="string">"星期四"</span>), FRIDAY(<span class="string">"星期五"</span>),SATURDAY(<span class="string">"星期六"</span>),SUNDAY(<span class="string">"星期日"</span>);</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Week</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="JDK中基本的三种注解"><a class="header-anchor" href="#JDK中基本的三种注解">¶</a>JDK中基本的三种注解</h1><ul><li>1)注解(Annotation)也被称为元数据(Metadata),用于修饰解释包、类、方法、属性、构造器、局部变量等数据信息。</li><li>2)和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息。</li><li>3)在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEEr中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替java EE旧版中所遗留的繁冗代码和XML配置等。</li></ul><img src="https://www.runoob.com/wp-content/uploads/2019/08/28124653-adf73c4cdcce4a63b7bf78efbe1a9cdf.jpg" alt="img" style="zoom: 80%;"><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230905164339036.png" alt="image-20230905164339036"></p><h2 id="Override"><a class="header-anchor" href="#Override">¶</a>@Override</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Override_</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Father</span> <span class="variable">father</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Father</span>();</span><br><span class="line">        <span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        father.fly();</span><br><span class="line">        son.fly();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>{</span><br><span class="line">        System.out.println(<span class="string">"Father fly&gt;&gt;&gt;"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>{</span><br><span class="line">    <span class="meta">@Override</span>   <span class="comment">// 此出若不写也可表示重写，编译器会去检测以下方法是否表示重写，</span></span><br><span class="line">    <span class="comment">//但若是写了Override，编译器会对此进行检验，若是不符合重写，会报错</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>{</span><br><span class="line">        System.out.println(<span class="string">"Son fly&gt;&gt;&gt;"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Deprecated"><a class="header-anchor" href="#Deprecated">¶</a>@Deprecated</h2><ol><li>@Deprecated 修饰某个元素，表示该元素已经过时</li><li>即不在推荐使用，但仍然可以使用</li></ol><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230905170744760.png" alt="image-20230905170744760"></p><h2 id="SuppressWarnings"><a class="header-anchor" href="#SuppressWarnings">¶</a>@SuppressWarnings</h2><ol><li>当我们不希望看到这些警告的时候，可以使用 @SuppressWarnings 注解来抑制警告信息</li><li>在{“”}中,可以写入你希望抑制(不显示)警告信息</li></ol><blockquote><ol><li>“all”：抑制所有警告。 说明：使用该属性可以忽略所有警告，但这种做法有潜在风险，可能会导致代码出现潜在的问题，所以建议只在特殊情况下使用。</li><li>“unchecked”：抑制类型转换检查的警告。 说明：Java编译器在进行类型转换时会发出警告，使用该属性可以忽略这些警告。</li><li>“deprecation”：抑制使用过时方法或类的警告。 说明：当我们使用某个已被标记为过时的方法或类时，编译器会发出警告。使用该属性可以忽略这些警告。</li><li>“rawtypes”：抑制使用原始类型（raw type）的警告。 说明：当我们使用未经参数化的泛型类型时，编译器会发出警告。使用该属性可以忽略这些警告。</li><li>“unchecked, rawtypes”：同时抑制类型转换检查和使用原始类型的警告。 说明：使用该属性可以同时忽略类型转换检查和使用原始类型的警告。</li></ol></blockquote><h1 id="异常"><a class="header-anchor" href="#异常">¶</a>异常</h1><h4 id="1、什么是异常，java提供异常处理机制有什么用？"><a class="header-anchor" href="#1、什么是异常，java提供异常处理机制有什么用？">¶</a>1、什么是异常，java提供异常处理机制有什么用？</h4><ul><li>什么是异常：程序执行过程中的<strong>不正常</strong>情况。</li><li>异常的作用：增强程序的 <strong><code>健壮性</code></strong>。</li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest01</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 实际上JVM在执行到此处的时候，会new异常对象：new ArithmeticException("/ by zero");</span></span><br><span class="line">        <span class="comment">// 并且JVM将new的异常对象抛出，打印输出信息到控制台了。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a / b;</span><br><span class="line">        System.out.println(a + <span class="string">"/"</span> + b + <span class="string">"="</span> + c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此处运行也会创建一个：ArithmeticException类型的异常对象。</span></span><br><span class="line">        System.out.println(<span class="number">100</span> / <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="2、java语言中异常是以什么形式存在的呢？"><a class="header-anchor" href="#2、java语言中异常是以什么形式存在的呢？">¶</a>2、java语言中异常是以什么形式存在的呢？</h4><p>异常在java中以 <strong><code>类</code></strong> 的形式存在，每一个 <em><strong>异常类</strong></em> 都可以创建 <em><strong>异常对象</strong></em>。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest02</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 通过“异常类”实例化“异常对象”</span></span><br><span class="line">        <span class="type">NumberFormatException</span> <span class="variable">nfe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumberFormatException</span>(<span class="string">"数字格式化异常！"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// java.lang.NumberFormatException: 数字格式化异常！</span></span><br><span class="line">        System.out.println(nfe);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="3、异常继承结构图"><a class="header-anchor" href="#3、异常继承结构图">¶</a>3、异常继承结构图</h4><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzE1OTQz%2Csize_16%2Ccolor_FFFFFF%2Ct_70.png" alt="在这里插入图片描述"></p><ul><li><p>Exception的直接子类：<strong>编译时异常</strong>（要求程序员在编写程序阶段必须预先对这些异常进行处理，如果不处理编译器报错，因此得名编译时异常。）。</p></li><li><p>RuntimeException：<strong>运行时异常</strong>。（在编写程序阶段程序员可以预先处理，也可以不管，都行。）</p></li></ul><h4 id="4、异常的分类"><a class="header-anchor" href="#4、异常的分类">¶</a>4、异常的分类</h4><p>异常分为 <strong><code>编译时异常</code></strong> 和 <strong><code>运行时异常</code></strong>。</p><p>所有异常都是在 <strong><code>运行阶段</code></strong> 发生的。因为只有程序运行阶段才可以 <strong>new</strong>对象。</p><p>因为异常的发生就是 <strong><code>new异常对象</code></strong>。</p><h5 id="4-1编译时异常因为什么而得名？"><a class="header-anchor" href="#4-1编译时异常因为什么而得名？">¶</a>4.1编译时异常因为什么而得名？</h5><p>因为编译时异常必须在编译(编写)阶段预先处理，如果不处理编译器报错，因此得名。</p><h5 id="4-2-编译时异常和运行时异常的区别？"><a class="header-anchor" href="#4-2-编译时异常和运行时异常的区别？">¶</a>4.2 编译时异常和运行时异常的区别？</h5><ul><li><p>编译时异常一般发生的概率 <strong><code>比较高</code></strong>。</p></li><li><p>运行时异常一般发生的概率 <strong><code>比较低</code></strong>。</p></li><li><p>编译时异常发生概率较高，需要在运行之前对其进行 <strong><code>预处理</code></strong>。</p></li><li><p>运行时异常发生概率较低，<strong>没必要</strong>提前进行预处理。</p></li></ul><h5 id="4-3编译时异常和运行时异常别称"><a class="header-anchor" href="#4-3编译时异常和运行时异常别称">¶</a>4.3编译时异常和运行时异常别称</h5><ul><li>编译时异常</li></ul><ol><li><strong>受检</strong>异常：CheckedException</li><li><strong>受控</strong>异常</li></ol><ul><li>运行时异常</li></ul><ol><li><strong>未受检</strong>异常：UnCheckedException</li><li><strong>非受控</strong>异常</li></ol><h4 id="5、异常的处理方式"><a class="header-anchor" href="#5、异常的处理方式">¶</a>5、异常的处理方式</h4><h5 id="5-1-throws"><a class="header-anchor" href="#5-1-throws">¶</a>5.1 throws</h5><p>在方法声明的位置上使用 <strong><code>throws</code></strong> <strong>关键字</strong>抛出，谁调用我这个方法，我就抛给谁。抛给 <strong><code>调用者</code></strong> 来处理。</p><p>这种处理异常的态度：<strong>上报</strong>。</p><h5 id="5-2-try…catch"><a class="header-anchor" href="#5-2-try…catch">¶</a>5.2 try…catch</h5><p><strong>注意：</strong></p><ul><li>只要异常没有捕捉，采用<strong>上报</strong>的方式，此方法的 <strong><code>后续代码不会执行</code></strong>。</li><li><strong>try语句块</strong>中的某一行出现异常，该行 <strong><code>后面的代码不会执行</code></strong>。</li><li>try…catch<strong>捕捉异常之后</strong>，后续代码可以执行。</li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException {</span><br><span class="line">    System.out.println(<span class="string">"m1 begin"</span>);</span><br><span class="line">    m2();</span><br><span class="line">    <span class="comment">// 以上代码出异常，这里是无法执行的。</span></span><br><span class="line">    System.out.println(<span class="string">"m1 over"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    m1();</span><br><span class="line">    <span class="comment">// m1方法出异常，下面代码不执行。</span></span><br><span class="line">    System.out.println(<span class="string">"hello world!"</span>);<span class="comment">//不执行</span></span><br><span class="line">} <span class="keyword">catch</span> (FileNotFoundException e){ </span><br><span class="line"><span class="comment">//异常处理</span></span><br><span class="line">    System.out.println(<span class="string">"出异常了！！"</span>);</span><br><span class="line">    System.out.println(e); </span><br><span class="line">}</span><br><span class="line">System.out.println(<span class="string">"hello world"</span>); <span class="comment">//会执行</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> {</span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"D:\\Download\\Javabean-addperson案例解析.docx"</span>);</span><br><span class="line">} <span class="keyword">catch</span>(FileNotFoundException e) {</span><br><span class="line">System.out.println(<span class="string">"文件不存在！"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">等同于</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"D:\\Download\\Javabean-addperson案例解析.docx"</span>);</span><br><span class="line">} <span class="keyword">catch</span>(Exception e) {<span class="comment">// 多态：Exception e = new FileNotFoundException();</span></span><br><span class="line">System.out.println(<span class="string">"文件不存在！"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"D:\\Download\\Javabean-addperson案例解析.docx"</span>);</span><br><span class="line">    fis.read();</span><br><span class="line">} <span class="keyword">catch</span>(IOException e){</span><br><span class="line">    System.out.println(<span class="string">"读文件报错了！"</span>);</span><br><span class="line">} <span class="keyword">catch</span>(FileNotFoundException e) {</span><br><span class="line">    System.out.println(<span class="string">"文件不存在！"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="8、异常两个重要方法"><a class="header-anchor" href="#8、异常两个重要方法">¶</a>8、异常两个重要方法</h4><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>String getMessage()</td><td>返回异常的详细消息字符串</td></tr><tr><td>void printStackTrace()</td><td>追踪堆栈异常信息(采用异步线程)</td></tr></tbody></table><h4 id="9、finally字句"><a class="header-anchor" href="#9、finally字句">¶</a>9、finally字句</h4><p>在finally子句中的代码是最后执行的，并且是 <strong><code>一定会执行</code></strong> 的，即使try语句块中的代码出现了异常。</p><p><strong>finally</strong>子句必须和<strong>try</strong>一起出现，不能单独编写。</p><h5 id="9-1-finally语句通常使用在哪些情况下呢？"><a class="header-anchor" href="#9-1-finally语句通常使用在哪些情况下呢？">¶</a>9.1 finally语句通常使用在哪些情况下呢？</h5><p>通常在finally语句块中完成 <strong><code>资源的释放/关闭</code></strong>。</p><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230514212441058.png" alt="image-20230514212441058"></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest10</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 声明位置放到try外面。这样在finally中才能用。</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"D:\\Download\\Javabean-addperson案例解析.docx"</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 这里一定会出现空指针异常！</span></span><br><span class="line">            s.toString();</span><br><span class="line">            System.out.println(<span class="string">"hello world!"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 流使用完需要关闭，因为流是占用资源的。</span></span><br><span class="line">            <span class="comment">// 即使以上程序出现异常，流也必须要关闭！</span></span><br><span class="line">            <span class="comment">// 放在这里有可能流关不了。</span></span><br><span class="line">            <span class="comment">//fis.close();</span></span><br><span class="line">        } <span class="keyword">catch</span> (FileNotFoundException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">catch</span>(IOException e){</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">catch</span>(NullPointerException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            System.out.println(<span class="string">"hello 浩克！"</span>);</span><br><span class="line">            <span class="comment">// 流的关闭放在这里比较保险。</span></span><br><span class="line">            <span class="comment">// finally中的代码是一定会执行的。</span></span><br><span class="line">            <span class="comment">// 即使try中出现了异常！</span></span><br><span class="line">            <span class="keyword">if</span> (fis != <span class="literal">null</span>) { <span class="comment">// 避免空指针异常！</span></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="comment">// close()方法有异常，采用捕捉的方式。</span></span><br><span class="line">                    fis.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="9-2try和finally联用，没有catch"><a class="header-anchor" href="#9-2try和finally联用，没有catch">¶</a>9.2try和finally联用，没有catch</h5><p><strong>以下代码的执行顺序：</strong></p><ol><li>先执行try…</li><li>再执行finally…</li><li>最后执行 return （return语句只要执行方法必然结束。）</li></ol><p><strong>注意：</strong></p><ul><li>try不能单独使用。</li><li>try finally可以联合使用。</li><li>放在finally语句块中的代码是一定会执行的</li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest11</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(<span class="string">"try..."</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            System.out.println(<span class="string">"finally..."</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里不能写语句，因为这个代码是无法执行到的。</span></span><br><span class="line">        <span class="comment">//System.out.println("Hello World!");</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="9-3-finally子句失效"><a class="header-anchor" href="#9-3-finally子句失效">¶</a>9.3 finally子句失效</h5><p><strong><code>System.exit(0);</code></strong> 只有这个可以治finally。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest12</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(<span class="string">"try..."</span>);</span><br><span class="line">            <span class="comment">// 退出JVM</span></span><br><span class="line">            System.exit(<span class="number">0</span>); <span class="comment">// 退出JVM之后，finally语句中的代码就不执行了！</span></span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            System.out.println(<span class="string">"finally..."</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="9-5-final-finally-finalize有什么区别？"><a class="header-anchor" href="#9-5-final-finally-finalize有什么区别？">¶</a>9.5 final finally finalize有什么区别？</h5><ul><li>final <strong>关键字</strong></li></ul><ol><li>final修饰的<code>类</code><strong>无法继承</strong></li><li>final修饰的<code>方法</code><strong>无法覆盖</strong></li><li>final修饰的<code>变量</code><strong>不能重新赋值</strong>。</li></ol><ul><li>finally <strong>关键字</strong></li></ul><ol><li>finally 和<strong>try</strong>一起联合使用。</li><li>finally语句块中的代码是<strong>必须执行</strong>的。</li></ol><ul><li>finalize <strong>标识符</strong></li></ul><ol><li>是一个Object类中的方法名。</li><li>这个方法是由垃圾回收器<strong>GC</strong>负责调用的</li></ol><h4 id="10、自定义异常（开发中常用）"><a class="header-anchor" href="#10、自定义异常（开发中常用）">¶</a>10、自定义异常（开发中常用）</h4><h5 id="10-1前言"><a class="header-anchor" href="#10-1前言">¶</a>10.1前言</h5><p>SUN提供的JDK内置的异常肯定是不够的用的。在实际的开发中，有很多业务，这些业务出现异常之后，JDK中都是没有的。和业务挂钩的。因此需要自定义异常。</p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230906113908532.png" alt="image-20230906113908532" style="zoom:60%;"><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230906113945256.png" alt="image-20230906113945256"></p><h5 id="10-2自定义异常步骤"><a class="header-anchor" href="#10-2自定义异常步骤">¶</a>10.2自定义异常步骤</h5><ol><li>第一步：编写一个类<strong>继承</strong> <strong><code>Exception</code></strong> 或者 <strong><code>RuntimeException</code></strong>.</li><li>第二步：提供两个 <strong><code>构造方法</code></strong>，一个<strong>无参数</strong>的，一个<strong>带有String参数</strong>的。</li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//栈操作异常：自定义异常！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackOperationException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>{ <span class="comment">// 编译时异常！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStackOperationException</span><span class="params">()</span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStackOperationException</span><span class="params">(String s)</span>{</span><br><span class="line">        <span class="built_in">super</span>(s);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="11、方法覆盖，时遗留的问题"><a class="header-anchor" href="#11、方法覆盖，时遗留的问题">¶</a>11、方法覆盖，时遗留的问题</h4><ul><li>重写之后的方法不能比重写之前的方法抛出更多（更宽泛）的异常，可以更少。<a href="https://blog.csdn.net/qq_44715943/article/details/115680718">方法覆盖</a></li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doOther</span><span class="params">()</span> <span class="keyword">throws</span> Exception{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译正常。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span> <span class="keyword">throws</span> RuntimeException{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译报错。</span></span><br><span class="line">    <span class="comment">/*public void doSome() throws Exception{</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    }*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译正常。</span></span><br><span class="line">    <span class="comment">/*public void doOther() {</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    }*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译正常。</span></span><br><span class="line">    <span class="comment">/*public void doOther() throws Exception{</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    }*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译正常。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doOther</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>注意：</strong><br>一般不会这样考虑，方法覆盖复制一份，然后重写就好了。</p><h4 id="12、总结异常中的关键字"><a class="header-anchor" href="#12、总结异常中的关键字">¶</a>12、总结异常中的关键字</h4><ul><li>异常捕捉：</li></ul><ol><li><strong>try</strong></li><li><strong>catch</strong></li><li><strong>finally</strong></li></ol><ul><li><strong>throws</strong> 在方法声明位置上使用，表示<strong>上报异常信息</strong>给<strong>调用者</strong>。</li><li><strong>throw</strong> <strong>手动抛出异常</strong>！</li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> <span class="keyword">throws</span> StackOperationException {</span><br><span class="line"><span class="keyword">if</span>(index &lt; <span class="number">0</span>){</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyStackOperationException</span>(<span class="string">"弹栈失败，栈已空！"</span>);<span class="comment">//手动抛出异常</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="包装类（Wrapper）"><a class="header-anchor" href="#包装类（Wrapper）">¶</a>包装类（Wrapper）</h1><h2 id="八个包装类的继承关系图"><a class="header-anchor" href="#八个包装类的继承关系图">¶</a>八个包装类的继承关系图</h2><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230906172124317.png" alt="image-20230906172124317" style="zoom:67%;"><h2 id="包装类方法"><a class="header-anchor" href="#包装类方法">¶</a>包装类方法</h2><p>包装类就是把String字符串类型（int，double，long…）</p><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230906192536744.png" alt="image-20230906192536744"></p><h2 id="String"><a class="header-anchor" href="#String">¶</a>String</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">"xyh"</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">"xyh"</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">"ww"</span>;</span><br><span class="line">System.out.println(a == b);<span class="comment">// T</span></span><br><span class="line">System.out.println(a.equals(b));<span class="comment">// T</span></span><br><span class="line">System.out.println(a == c);<span class="comment">// F</span></span><br><span class="line">System.out.println(a.equals(c));<span class="comment">// F</span></span><br></pre></td></tr></tbody></table></figure><p><code>equals</code>可以看作只检查内容，而<code>==</code>是不仅检查内容，还要检查地址</p><h2 id="String类常用方法"><a class="header-anchor" href="#String类常用方法">¶</a>String类常用方法</h2><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230907164233737.png" alt="image-20230907164233737" style="zoom:67%;"><blockquote><p>equals/区分大小写，判断内容是否相等<br>equalslgnoreCase/忽略大小写的判断内容是否相等<br>length/获取字符的个数，字符串的长度<br>indexOf/获取字符在字符串中第1次出现的索引，索引从0开始，如果找不到，返回-1<br>lastIndexOf//获取字符在字符串中最后1次出现的索引，索引从0开始，如找不到，返回-1<br>substring/截取指定范围的子串<br>trim/去前后空格<br>charAt:获取某索引处的字符，注意不能使用Str[index]这种方式.</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WrapperMethed</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">//equals/区分大小写，判断内容是否相等</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="string">"Hello"</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="string">"hello"</span>;</span><br><span class="line">        System.out.println(n1.equals(n2));  <span class="comment">// F</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//equalslgnoreCase/忽略大小写的判断内容是否相等</span></span><br><span class="line">        System.out.println(n1.equalsIgnoreCase(n2));    <span class="comment">// T</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//length/获取字符的个数，字符串的长度</span></span><br><span class="line">        System.out.println(n1.length());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//indexOf/获取字符在字符串中^^第1次^^出现的索引，索引从0开始，如果找不到，返回-1</span></span><br><span class="line">        System.out.println(n1.indexOf(<span class="string">"o"</span>));    <span class="comment">//4,查找字符下标</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//lastIndexOf/获取字符在字符串中^^最后1次^^出现的索引，索引从0开始，如找不到，返回-1</span></span><br><span class="line">        System.out.println(n1.lastIndexOf(<span class="string">"l"</span>));    <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//substring/截取指定范围的子串</span></span><br><span class="line">        System.out.println(n1.substring(<span class="number">2</span>,<span class="number">5</span>));  <span class="comment">//llo</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//trim/去前后空格</span></span><br><span class="line">        <span class="comment">//charAt:获取某索引处的字符，注意不能使用Str[index]这种方式.D</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="String格式化"><a class="header-anchor" href="#String格式化">¶</a>String格式化</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">第一种方式</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.format(<span class="string">"数据转换成各个%s"</span>, n1);</span><br><span class="line"></span><br><span class="line">第二种方式</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">"数据转换成各个%s"</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">info2</span> <span class="operator">=</span> String.format(str2,n2);</span><br></pre></td></tr></tbody></table></figure><blockquote><ul><li>//1.%s,%d,%.2f%c称为占位符</li><li>//2,这些占位符由后面变量来替换</li><li>//3.%s表示后面由字符串来替换</li><li>//4,%d是整数来替换</li><li>//5,%.2F表示使用小数来替换，替换后，只会保留小数点两位，并且进行四舍五入的处理</li><li>/6,%c使用char类型米替换</li></ul></blockquote><h2 id="StringBuffer"><a class="header-anchor" href="#StringBuffer">¶</a>StringBuffer</h2><h3 id="和String的区别"><a class="header-anchor" href="#和String的区别">¶</a>和String的区别</h3><p>Java中的String和StringBuffer是两种不同的字符串类型，它们有以下几个主要区别：</p><ol><li>可变性：String是<code>不可变的字符串</code>类型，即一旦创建了一个String对象，它的<code>值就不能被修改</code>。而StringBuffer是<code>可变</code>的字符串类型，可以通过调用其方法来修改字符串的内容。</li><li>性能：由于String是不可变的，每次对String对象的操作都会创建一个新的String对象，这会导致频繁的内存分配和回收，对于大量的字符串操作会降低性能。而StringBuffer是可变的，可以在原有对象上直接进行修改，避免了频繁的内存分配和回收，因此在大量字符串拼接的场景下性能更好。</li><li>方法支持：由于String不可变，它提供了更多的方法来操作和获取字符串的内容，如substring、length、charAt等。而StringBuffer提供了一些用于修改和操作字符串的方法，如append、insert、delete等。</li></ol><p><strong>综上所述，String和StringBuffer在可变性、线程安全性、性能和方法支持等方面存在差异。根据具体的需求，选择合适的字符串类型可以充分发挥其优点和功能。<code>当需要频繁地修改字符串时</code>，建议使用StringBuffer；当字符串不需要被修改且在<code>多线程</code>环境下使用时，使用String更为合适。</strong></p><h1 id="线程"><a class="header-anchor" href="#线程">¶</a>线程</h1><h3 id="一-线程创建"><a class="header-anchor" href="#一-线程创建">¶</a>一.线程创建</h3><h3 id="线程基础知识介绍"><a class="header-anchor" href="#线程基础知识介绍">¶</a>线程基础知识介绍</h3><p>什么是线程？为什么要使用线程？</p><p>​    在没有使用到线程的程序中，我们总是只能串行的执行程序，也就是我们的程序一次性只能进行一个操作。而我们使用微信进行视频聊天的时候，我们可以一边视频，一边和其他人打字聊天。这就是多线程，可以一个线程负责视频聊天，一个线程负责打字聊天，使用的任然是一个程序。在日常使用场景中，多线程是必要的。</p><h3 id="创建方法一：继承Thread类"><a class="header-anchor" href="#创建方法一：继承Thread类">¶</a>创建方法一：继承Thread类</h3><p>​    Thread单词意思就是线程的意思，是Java提供的一个线程类。可以自己创建一个类然后继承Thread，重写run方法。run方法写入你想要进行多线程运行的代码。</p><p>​    通过你建的类，实例化一个对象；通过这个对象调用start()方法，该对象就可以进行多线程操作了。</p><p>创建步骤：</p><p>​    1.继承Thread类，重写run方法</p><p>​    2.实例化一个对象，调用start方法（就是执行run函数里面的内容）</p><p>代码演示：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//1 创建两个类，继承Thread，都重写run方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) {</span><br><span class="line">            System.out.println(<span class="string">"Thread1 running!"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) {</span><br><span class="line">            System.out.println(<span class="string">"Thread2 running!"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">//2 对这两个类分别实例化一个对象，调用start方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Thread1</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread1</span>();</span><br><span class="line">        <span class="type">Thread2</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread2</span>();</span><br><span class="line"> </span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>​    运行结果发现，Thread1线程和Thread2线程轮流上处理机执行，由此可知该段程序确实实现了多线程操作</p><h3 id="创建方法二：实现Runnable接口"><a class="header-anchor" href="#创建方法二：实现Runnable接口">¶</a>创建方法二：实现Runnable接口</h3><p>Runnable是一个接口，该接口是一个函数式接口（不知道函数式接口的伙伴，可以看看我上一篇博客哦），只有一个抽象方法run</p><p>创建方法一的Thread类就是实现了Runnable接口，查看源码如下图：</p><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230514215608092.png" alt="image-20230514215608092"></p><p>​    那为什么已经有Java开发人员已经给我们封装好的Thread类，有更多的方法可以供我们调用，我们还要用Runnable接口来实现线程，不是很冗余嘛，容我卖个关子，会在代码中解释。</p><p>创建步骤：</p><p>​    1 创建一个类实现Runnable接口，重写run方法</p><p>​    2 通过该类实例化对象</p><p>​    3 将实例化的对象作为参数传到Thread实现线程，再调用start方法</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//1 创建Demo1实现Runnable接口，重写run方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>{</span><br><span class="line">    <span class="comment">//run方法模拟买票场景</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">//设置票数为10</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 只要票数有剩余，就可以一直进行买票</span></span><br><span class="line">        <span class="keyword">while</span> (ticket &gt; <span class="number">0</span>){</span><br><span class="line">            <span class="comment">// Thread.currentThread()该静态方法可以获得当前运行的线程 getName()得到线程名称</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"   get   "</span> +ticket--);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">//2 实例化一个demo1对象</span></span><br><span class="line">        <span class="type">Demo1</span> <span class="variable">demo1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo1</span>();</span><br><span class="line">        <span class="comment">//3 将实例化的对象作为参数传到Thread实现线程</span></span><br><span class="line">        <span class="comment">//Thread有传入一个对象的构造器，构造器还能加入线程的名称</span></span><br><span class="line">        <span class="comment">//实例化了多个Thread类，再调用start方法，就能实现多个线程对同一个对象进行操作</span></span><br><span class="line">        <span class="comment">//这就是为什么还要用Runnable接口来实现线程的原因</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo1,<span class="string">"pp"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo1,<span class="string">"mc"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo1,<span class="string">"pp1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo1,<span class="string">"mc1"</span>).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面代码用到的构造器：</p><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230514215740525.png" alt="image-20230514215740525"></p><h2 id="创建方法三：实现Callable接口；线程池"><a class="header-anchor" href="#创建方法三：实现Callable接口；线程池">¶</a>创建方法三：实现Callable接口；线程池</h2><p>​    Callable也是一个接口，可以使用到线程池。当多线程场景下，我们一直创建或者销毁线程，对性能影响都很大，如果我们提前创建好多个线程，放入线程池，使用时直接获取，使用完放回池中，就可以避免一直创建、销毁，达到重复利用。</p><h3 id="线程池"><a class="header-anchor" href="#线程池">¶</a>线程池</h3><p><strong>ExecutorService</strong>   线程池接口</p><p>常用方法：</p><ul><li>​    void <strong>execute</strong>(Runnable command); 执行任务，没有返回值，一般用来执行<strong>Runnable</strong></li><li>​    <t> <strong>Future</strong><t> submit(Callable<t> task);执行任务，有返回值，一般用来执行<strong>Callable</strong></t></t></t></li><li>​    void shutdown();关闭连接池</li></ul><p><strong>Executors</strong> 该类用于创建线程池</p><h3 id="Callable接口实现多线程"><a class="header-anchor" href="#Callable接口实现多线程">¶</a>Callable接口实现多线程</h3><p>​    实现callable接口需要返回值类型 ，而上述两种方法是不需要返回值的。不同与上述两种方法，实现Callable需要重写call方法，而不是run方法，并且call方法需要抛出异常。</p><p>创建步骤：</p><p>​    1 创建一个类实现Callable接口，重写call方法</p><p>​    2 创建目标对象，即通过该类实例化对象</p><p>​    3 创建执行的服务，可通过实现线程池来创建</p><p>​    4 提交执行 callable为submit方法</p><p>​    5  获取结果</p><p>​    6 关闭服务</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*实现callable接口需要返回值类型*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Boolean&gt; {</span><br><span class="line">    <span class="comment">//重写call方法需要抛出异常</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException {</span><br><span class="line">        <span class="comment">//1 创建目标对象</span></span><br><span class="line">        <span class="type">TestCallable</span> <span class="variable">testCallable1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestCallable</span>();</span><br><span class="line">        <span class="type">TestCallable</span> <span class="variable">testCallable2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestCallable</span>();</span><br><span class="line">        <span class="type">TestCallable</span> <span class="variable">testCallable3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestCallable</span>();</span><br><span class="line">        <span class="comment">//2 创建执行的服务</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">ser</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//3 提交执行</span></span><br><span class="line">        Future&lt;Boolean&gt; f1 = ser.submit(testCallable1);</span><br><span class="line">        Future&lt;Boolean&gt; f2 = ser.submit(testCallable2);</span><br><span class="line">        Future&lt;Boolean&gt; f3 = ser.submit(testCallable3);</span><br><span class="line">        <span class="comment">//4 获取结果</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">r1</span> <span class="operator">=</span> f1.get();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">r2</span> <span class="operator">=</span> f2.get();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">r3</span> <span class="operator">=</span> f3.get();</span><br><span class="line">        <span class="comment">//5 关闭服务</span></span><br><span class="line">        ser.shutdown();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>​</p>]]></content>
      
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单地认识一下 HTML</title>
      <link href="/2023/07/07/html/"/>
      <url>/2023/07/07/html/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML"><a class="header-anchor" href="#HTML">¶</a>HTML</h1><p>网页设计有许多应用场景和日常使用案例，以下是一些常见的：</p><ol><li>企业官网：企业可以通过网页官网展示公司的信息、产品、服务等内容，提高知名度和品牌形象。</li><li>电子商务平台：在线商店或电商平台可以通过网页设计来展示商品、促销活动、购物车和结账等功能，方便用户浏览和购买商品。</li><li>社交媒体平台：社交媒体如Facebook、Twitter、Instagram等需要提供一个易于使用、吸引人的界面，以便用户分享内容、与朋友互动。</li><li>博客和新闻网站：博客网站和新闻网站需要具备良好的读取性能、排版和页面设计，以便读者更好地阅读文章和获取信息。</li><li>教育和培训网站：教育和培训机构通过网页设计来呈现课程、学习资源、教师介绍等内容，在线辅导和互动等功能也需要进行良好的设计。</li><li>政府和公共服务机构：政府和公共服务机构利用网页设计来提供公共服务、政策法规、信息发布等功能，方便民众获取所需的信息和服务。</li><li>游戏和娱乐网站：游戏和娱乐网站需要吸引用户的注意力，提供游戏、视频、音乐等娱乐内容，同时也需要良好的用户体验和易用性。</li></ol><p>这些只是一小部分网页设计的应用场景和日常使用案例。随着技术的不断发展和创新，新的应用场景和使用方式将不断涌现。</p><h3 id="外部样式表"><a class="header-anchor" href="#外部样式表">¶</a>外部样式表</h3><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"###"</span>&gt;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="基础样式"><a class="header-anchor" href="#基础样式">¶</a>基础样式</h2><h3 id="text"><a class="header-anchor" href="#text">¶</a>text</h3><h4 id="test-align-文本对齐"><a class="header-anchor" href="#test-align-文本对齐">¶</a>test-align(文本对齐)</h4><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> {</span><br><span class="line">###<span class="selector-pseudo">:left</span>;//左对齐</span><br><span class="line">###：<span class="attribute">right</span>;//右对齐</span><br><span class="line">###：center;//居中对齐</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="text-decoration（文本装饰）"><a class="header-anchor" href="#text-decoration（文本装饰）">¶</a>text-decoration（文本装饰）</h4><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> {</span><br><span class="line">###：<span class="attribute">none</span>//默认，，没有装饰线</span><br><span class="line">###：underline//下划线，链接<span class="selector-tag">a</span>自带下划线</span><br><span class="line">###：overline//上划线</span><br><span class="line">###：line-through //删除线</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="text-indent（文本缩进）"><a class="header-anchor" href="#text-indent（文本缩进）">¶</a>text-indent（文本缩进）</h4><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> {</span><br><span class="line">###：<span class="number">20px</span>；//首行缩进<span class="number">2</span>格</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">div {</span><br><span class="line">###：2em;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>em</code>是一个相对单位，就是当前元素(font-size)1个文字的大小，如果当前元素没有设置大小，则会按照父元素的1个文字大小。</p><h4 id="line-height（行间距）"><a class="header-anchor" href="#line-height（行间距）">¶</a>line-height（行间距）</h4><h3 id="flex：1（比例布局）"><a class="header-anchor" href="#flex：1（比例布局）">¶</a>flex：1（比例布局）</h3><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>{</span><br><span class="line"><span class="attribute">display</span>:flex</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.box1</span>{</span><br><span class="line"><span class="attribute">flex</span>:<span class="number">1</span></span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.box2</span>{</span><br><span class="line"><span class="attribute">flex</span>:<span class="number">1</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="%5Bflex%E7%AC%94%E6%AF%94%E4%BE%8B%E5%B8%83%E5%B1%80%EF%BC%8C%E4%BD%A0%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97_%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9_bilibili%5D(https://www.bilibili.com/video/BV1rT411n7W5/?spm_id_from=333.788&amp;vd_source=82b1091d86f2e188ef7a48f733b4c383)">长这样🔜</a></p><h3 id="transition-动画过渡"><a class="header-anchor" href="#transition-动画过渡">¶</a>transition(动画过渡)</h3><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-class">.img</span>{</span><br><span class="line"><span class="attribute">width</span>:<span class="number">200px</span>//宽度</span><br><span class="line">height:<span class="number">200px</span>//高度</span><br><span class="line">transition:all <span class="number">2s</span>//所有角动画过渡</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.img</span><span class="selector-pseudo">:hover</span>{//鼠标接触时</span><br><span class="line"><span class="attribute">border-radius</span>:<span class="number">50%</span>//圆角</span><br><span class="line">//过度面罩</span><br><span class="line">-webkit-mask-image:<span class="built_in">linear-gradient</span>(<span class="built_in">rgb</span>(<span class="number">227</span>,<span class="number">227</span>,<span class="number">227</span>),<span class="number">90%</span>,transparent)</span><br><span class="line">opacity:<span class="number">0.2</span>//保留角边，逐渐透明</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>transition + <code>ease-in</code><code>ease-out</code></p><p>​慢进慢出</p><h3 id="CSS快速改变原生颜色"><a class="header-anchor" href="#CSS快速改变原生颜色">¶</a>CSS快速改变原生颜色</h3><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=checkbox]</span>{//单选框</span><br><span class="line">accent-<span class="attribute">color</span>:red//修改为红色</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//统一颜色</span><br><span class="line"><span class="selector-pseudo">:root</span>{</span><br><span class="line">accent-<span class="attribute">color</span>:deeppink//深粉</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="background（图片）"><a class="header-anchor" href="#background（图片）">¶</a>background（图片）</h3><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>{</span><br><span class="line"><span class="attribute">width</span>:<span class="number">200px</span>;//box宽</span><br><span class="line"><span class="attribute">height</span>:<span class="number">200px</span>;//box高</span><br><span class="line"><span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">'/img'</span>);</span><br><span class="line"><span class="attribute">background-size</span>: <span class="number">100px</span> <span class="number">100px</span>;//调整图片大小</span><br><span class="line"><span class="attribute">background-repeat</span>: repeat-x;//水平重复图像</span><br><span class="line"><span class="attribute">background-repeat</span>: repeat-y;//纵向重复图像</span><br><span class="line"><span class="attribute">background-position</span>: center bottom//底部居中</span><br><span class="line">background-position: right bottom//底部右对齐</span><br><span class="line">background-position: <span class="number">0</span> <span class="number">0</span> //调整坐标</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="calc（动态计算）"><a class="header-anchor" href="#calc（动态计算）">¶</a>calc（动态计算）</h3><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>{</span><br><span class="line"><span class="attribute">width</span> :<span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">50px</span>);//假设初值为<span class="number">500px</span>，得<span class="number">450px</span></span><br><span class="line">    <span class="attribute">width</span> :<span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">100px</span> * <span class="number">4</span>);//<span class="number">100px</span></span><br><span class="line">    <span class="attribute">width</span> :<span class="built_in">calc</span>(<span class="number">100%</span> / <span class="number">3</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="before-after-伪元素"><a class="header-anchor" href="#before-after-伪元素">¶</a>::before &amp; ::after(伪元素)</h3><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-class">.content</span><span class="selector-pseudo">::before</span>{//在头部插入文本</span><br><span class="line"><span class="attribute">content</span>:<span class="string">"《西江月·平山堂》"</span>;</span><br><span class="line"><span class="attribute">color</span>:red;//字体颜色</span><br><span class="line"><span class="attribute">font-weight</span>:<span class="number">600</span>;//调整字体粗细</span><br><span class="line"><span class="attribute">background</span>:<span class="built_in">rgb</span>(<span class="number">255</span>,<span class="number">192</span>,<span class="number">0</span>);//背景颜色</span><br><span class="line"><span class="attribute">display</span>:block;//转为块元素，独占一行</span><br><span class="line"><span class="attribute">width</span>:<span class="number">50%</span>//调整块宽度</span><br><span class="line">padding:<span class="number">10px</span> <span class="number">0</span>//调整块高度</span><br><span class="line">margin:<span class="number">10px</span> <span class="number">0</span>//设置外边距</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.content</span><span class="selector-pseudo">::after</span>{//在尾部插入文本</span><br><span class="line"><span class="attribute">content</span>:<span class="string">"--苏轼"</span>；</span><br><span class="line">padding-left:<span class="number">20px</span>;//设置元素左内边距</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230505000416933-1683216266648-1.png" alt="image-20230505000416933" style="zoom: 67%;"><h2 id="Emmet语法"><a class="header-anchor" href="#Emmet语法">¶</a>Emmet语法</h2><hr><h3 id="1-1快速生成HTML结构语法"><a class="header-anchor" href="#1-1快速生成HTML结构语法">¶</a>1.1快速生成HTML结构语法</h3><ol><li>生成标签直接输入标签名按tab键即可比如div然后tab键，就可以生成<div></div></li><li>如果想要生成多个相同标签加上<code>*</code>就可以了比如div*<code>3就可以快速生成3个</code>div`</li><li>如果有父子级关系的标签，可以用<code>&gt;</code>比如<code>u&gt;</code>就可以了</li><li>如果有兄弟关系的标签，用<code>+</code>就可以了比如<code>div</code>+<code>p</code></li><li>如果生成带有类名或者id名字的，直接写<code>.demo</code>或者<code>#two tab</code>键就可以了</li><li>如果生成的<code>div</code>类名是有顺序的，可以用自增符号$</li></ol><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> + tab ==&gt; <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">div*3</span><br><span class="line">li&gt;lu</span><br><span class="line">div+p ==&gt; <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">.demo ==&gt; <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"demo"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="CSS的复合选择器"><a class="header-anchor" href="#CSS的复合选择器">¶</a>CSS的复合选择器</h1><hr><h2 id="1-1后代选择器"><a class="header-anchor" href="#1-1后代选择器">¶</a>1.1后代选择器</h2><p>后代选择器 又称为包含选择器，可以选择元素里面子元素。其写法就是把外层标签写在前面，内层标签写在后面，中间用空格分隔。当标签发生嵌套时，内层标签就成为外层标签的后代。</p><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230521194859083.png" alt="image-20230521194859083"></p><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*-HTML*/</span></span><br><span class="line">&lt;<span class="selector-tag">ol</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">li</span>&gt;&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">ol</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*CSS*/</span></span><br><span class="line"><span class="selector-tag">ol</span> <span class="selector-tag">li</span> {}</span><br></pre></td></tr></tbody></table></figure><h2 id="1-2-子元素选择器"><a class="header-anchor" href="#1-2-子元素选择器">¶</a>1.2 子元素选择器</h2><p>子元素选择器（子选择器）,只能选择作为某元素的最近一级子元素</p><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230521195335551.png" alt="image-20230521195335551"></p><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*HTML*/</span></span><br><span class="line">&lt;<span class="selector-tag">ol</span> class="<span class="selector-tag">nav</span>"&gt;</span><br><span class="line">&lt;<span class="selector-tag">li</span>&gt;&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">ol</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*CSS*/</span></span><br><span class="line"><span class="selector-class">.nav</span>&gt;<span class="selector-tag">li</span> {}</span><br></pre></td></tr></tbody></table></figure><h2 id="1-3-并集选择器"><a class="header-anchor" href="#1-3-并集选择器">¶</a>1.3 并集选择器</h2><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230521200930891-1684670977486-1.png" alt="image-20230521200930891"></p><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*-HTML*/</span></span><br><span class="line">&lt;<span class="selector-tag">ol</span> class="<span class="selector-tag">nav</span>"&gt;</span><br><span class="line">&lt;<span class="selector-tag">li</span>&gt;&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">ol</span>&gt;</span><br><span class="line"><span class="comment">/*CSS*/</span></span><br><span class="line"><span class="selector-tag">div</span>,</span><br><span class="line"><span class="selector-tag">p</span>{}</span><br></pre></td></tr></tbody></table></figure><h2 id="1-4-链接伪类选择器"><a class="header-anchor" href="#1-4-链接伪类选择器">¶</a>1.4 链接伪类选择器</h2><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span><span class="comment">/*选择所有未被访问的链接*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span><span class="comment">/*选择所有已被访问的链接*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span><span class="comment">/*选择鼠标箭头指针位于其上的链接*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span><span class="comment">/*选择活动链接（鼠标按下未弹起的链接）*/</span></span><br></pre></td></tr></tbody></table></figure><p>==注意：==</p><p>为确保生效，请按照LVHA顺序声明：<code>link --&gt; :visited --&gt; :hover --&gt; :active</code></p><h2 id="1-5-focus伪类选择器"><a class="header-anchor" href="#1-5-focus伪类选择器">¶</a>1.5 focus伪类选择器</h2><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*把获得光标的input表单元素选取出来*/</span></span><br><span class="line"><span class="comment">/*-HTML*/</span></span><br><span class="line">&lt;<span class="selector-tag">input</span> type="text"&gt;</span><br><span class="line"><span class="comment">/*CSS*/</span></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:focus</span> {}</span><br></pre></td></tr></tbody></table></figure><h1 id="元素显示模式"><a class="header-anchor" href="#元素显示模式">¶</a>元素显示模式</h1><hr><p>HTML元素一般分为<code>块元素</code>和<code>行内元素</code>两种类型.</p><h2 id="1-块元素"><a class="header-anchor" href="#1-块元素">¶</a>1.块元素</h2><hr><p>常见的块元素有<code>&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;i&gt;</code>等，其中<code>&lt;div&gt;</code>标签是==最典型的块元素==。<br>块级元素的特点：</p><ol><li>比较霸道，自己独占一行。</li><li>高度，宽度、外边距级内边距都可以控制</li><li>宽度默认是容器（父级宽度）的100%。</li><li>是一个容器及盒子，里面可以放行内或者块级元素</li></ol><p><strong>注意：</strong></p><ul><li><p>文字类的元素内不能使用块级元素</p></li><li><p>标签主要用于存放文字，因此</p><p>里面不能放块级元素，特别是不能放</p><div></div></li><li><p>同理，</p><h1>~</h1><h6>等都是文字类块级标签，里面也不能放其他块级元素<p></p></h6></li></ul><h2 id="2-行内元素"><a class="header-anchor" href="#2-行内元素">¶</a>2.行内元素</h2><p>常见的行内元素有<code>&lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、&lt;span&gt;</code>等，其中<br><span>标签是最典型的行内元素。有的地方也将行内元素称为<strong>内联元素</strong>。<br><strong>行内元素的特点：</strong></span></p><ol><li>相邻行内元素在一行上，一行可以显示多个。</li><li>高、宽直接设置是无效的。</li><li>默认宽度就是它本身内容的宽度。</li><li>行内元素只能容纳文本或其他行内元素。</li></ol><p><strong>注意：</strong></p><ol><li>链接里面不能再放链接。</li><li>特殊情况链接<a>里面可以放块级元素，但是给</a><a>转换一下块级模式最安全。</a></li><a></a></ol><a></a><h2 id="3-行内块元素"><a></a><a class="header-anchor" href="#3-行内块元素">¶</a>3.行内块元素</h2><p>在行内元素中有几个特殊的标签一<img>、<input>、,它们同时具有块元素和行内元素的特点。有些资料称它们为<code>行内块元素</code>。</p><p>行内块元素的特点：</p><ol><li>和相邻行内元素（行内块）在一行上，但是他们之间会有空白缝隙。一行可以显示多个（行内元素特点）。</li><li>默认宽度就是它本身内容的宽度（行内元素特点）。</li><li>高度，行高、外边距以及内边距都可以控制（块级元素特点）。</li></ol><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*显示模式的转换：</span></span><br><span class="line"><span class="comment">  行内 转 块元素*/</span></span><br><span class="line"><span class="attribute">display</span>：block；</span><br><span class="line"><span class="comment">/*反之*/</span></span><br><span class="line"><span class="attribute">display</span>: inline;</span><br><span class="line"><span class="comment">/*行内块*/</span></span><br><span class="line"><span class="attribute">display</span>: inline-block;</span><br></pre></td></tr></tbody></table></figure><h1 id="⭐盒子模型⭐"><a class="header-anchor" href="#⭐盒子模型⭐">¶</a>⭐盒子模型⭐</h1><hr><h2 id="网页布局的本质"><a class="header-anchor" href="#网页布局的本质">¶</a>网页布局的本质</h2><p>网页布局的过程：</p><ol><li>先准备好相关的网页元素，网页元素基本都是盒子box</li><li>利用CSS设置好盒子的样式，然后摆放到相应位置</li><li>往盒子里面装内容</li></ol><p><code>核心本质:</code>就是利用CSS摆盒子</p><h2 id="组成部分"><a class="header-anchor" href="#组成部分">¶</a>组成部分</h2><p>所谓盒子模型：就是把HTML页面中的布局元索看作是一个矩形的盒子，也就是一个盛装内容的容器。<br>CSS盒子模型本质上是一个盒子，封装周围的HTML元素，它包括：边框、外边距、内边距、和实际内容</p><h2 id="边框"><a class="header-anchor" href="#边框">¶</a>边框</h2><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attribute">border</span>:border-width||border-style||border-color</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>border-width</td><td>定义边框粗细</td></tr><tr><td>border-style</td><td>边框的样式</td></tr><tr><td>border-color</td><td>边框颜色</td></tr></tbody></table><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>{</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">border-color</span>: blue;</span><br><span class="line">    <span class="attribute">border-style</span>: solid;</span><br><span class="line">    <span class="comment">/* solid实线边框 */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>border-style</th><th>作用</th></tr></thead><tbody><tr><td>solid</td><td>实线</td></tr><tr><td>dashed</td><td>虚线</td></tr><tr><td>dotted</td><td>点线</td></tr><tr><td>double</td><td>双线</td></tr></tbody></table><p><code>边框简写:</code></p><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attribute">border</span>:<span class="number">1px</span> soild red;没有顺序</span><br></pre></td></tr></tbody></table></figure><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attribute">border-top</span>:<span class="number">1px</span> solid red;只设置上边框</span><br></pre></td></tr></tbody></table></figure><h2 id="文字垂直居中"><a class="header-anchor" href="#文字垂直居中">¶</a>文字垂直居中</h2><p>CSS没有给我们提供文字垂直居中的代码.这里我们可以使用一个小技巧来实现<br>解决方案：让==文字的行高等于盒子的高度==就可以让文字在当前盒子内垂直居中</p><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line"><span class="attribute">line-height</span>: <span class="number">40px</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="内边距"><a class="header-anchor" href="#内边距">¶</a>内边距</h2><p>padding属性用于设置内边距，即边框与内容之间的距离</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>padding-left</td><td>左内边距</td></tr><tr><td>padding-right</td><td>右内边距</td></tr><tr><td>padding-top</td><td>上内边距</td></tr><tr><td>padding-bottom</td><td>下内边距</td></tr></tbody></table><p>复合写法</p><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230630184721337-1688122047171-1.png" alt="image-20230630184721337"></p><h2 id="外边距"><a class="header-anchor" href="#外边距">¶</a>外边距</h2><p>margin属性用于设置外边距，即控制盒子和盒子之间的距离</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>margin-left</td><td>左外边距</td></tr><tr><td>margin-right</td><td>右外边距</td></tr><tr><td>margin-top</td><td>上外边距</td></tr><tr><td>margin-bottom</td><td>下外边距</td></tr></tbody></table><h2 id="块元素水平居中"><a class="header-anchor" href="#块元素水平居中">¶</a>块元素水平居中</h2><p>外边距可以让<em><strong>块级盒子</strong></em>水平居中，但是必须满足两个条件：👍</p><ol><li>盒子必须指定了宽度(width)。</li><li>盒子左右的外边距都设置为auto。</li></ol><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br></pre></td></tr></tbody></table></figure><p><strong>外边距合并</strong></p><p>1.相邻块元素垂直外边距的合并<br>当上下相邻的两个块元素（兄弟关系）相遇时，如果上面的元素有下外边距margin-bottom,下面的元素有上外边距margin-top,则他们之间的垂直间距不是margin-bottom与margin-top之和。取两个值中的<em>较大者这种现象被称为相邻块元素垂直外边距的合并</em>。</p><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230701163821796-1688200705841-1.png" alt="image-20230701163821796"></p><p><strong>嵌套块元素垂直外边距的塌陷</strong></p><p>当父子元素同时设置相同外边距</p><h1 id="背景"><a class="header-anchor" href="#背景">¶</a>背景</h1><h2 id="背景图片"><a class="header-anchor" href="#背景图片">¶</a>背景图片</h2><p>background-image属性描述了元素的背景图像。实际开发常见于logo或者一些装饰性的小图片或者是超大的背景图片，优点是非常便于控制位置(精灵图也是一种运用场景)</p><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attribute">background-image</span>:;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line">//背景平铺</span><br><span class="line"><span class="attribute">background-repeat</span>:repeat;</span><br><span class="line"><span class="attribute">background-repeat</span>:no-repeat ;</span><br><span class="line"><span class="attribute">background-repeat</span>:repeat-x;</span><br><span class="line"><span class="attribute">background-repeat</span>:repeat-y;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line">//方位名词</span><br><span class="line">//<span class="attribute">background-position</span>: x y;</span><br><span class="line"><span class="attribute">background-position</span>: center left;</span><br><span class="line"><span class="attribute">background-position</span>: <span class="number">50px</span><span class="number">50px</span>;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line">//背景附着</span><br><span class="line"><span class="attribute">background-attachment</span>:fixed;//固定</span><br></pre></td></tr></tbody></table></figure><p>简写顺序:</p><p><strong><code>background:  背景颜色  背景图片地址  背景平铺  背景图像滚动  背景图片位置;</code></strong></p><table><thead><tr><th>上</th><th>中</th><th>下</th><th>左</th><th>右</th></tr></thead><tbody><tr><td>top</td><td>center</td><td>bottom</td><td>left</td><td>right</td></tr></tbody></table><h2 id="背景颜色"><a class="header-anchor" href="#背景颜色">¶</a>背景颜色</h2><p>透明度由0~1.</p><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attribute">background-color</span>:<span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,透明度);</span><br></pre></td></tr></tbody></table></figure><h1 id="CSS三大特性"><a class="header-anchor" href="#CSS三大特性">¶</a>CSS三大特性</h1><h2 id="层叠性"><a class="header-anchor" href="#层叠性">¶</a>层叠性</h2><p>相同选择器给设置相同的样式，此时一个样式就会盖（层叠）另一个冲突的样式。层叠性主要解决样式冲突的问题层雪性原侧：</p><ul><li>样式冲突，遵循的原则是就近原测，哪个样式离结构近，就执行哪个样式</li><li>样式不冲突，不会层叠</li></ul><h2 id="继承性"><a class="header-anchor" href="#继承性">¶</a>继承性</h2><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230625232619757-1687706783543-1-1687706787135-3.png" alt="image-20230625232619757"></p><h2 id="优先级"><a class="header-anchor" href="#优先级">¶</a>优先级</h2><table><thead><tr><th>选择器</th><th>选择器权重</th></tr></thead><tbody><tr><td>继承 或 *</td><td>0,0,0,0</td></tr><tr><td>元素选择器</td><td>0,0,0,1</td></tr><tr><td>类选择器,伪类选择器</td><td>0,0,1,0</td></tr><tr><td>ID选择器</td><td>0,1,0,0</td></tr><tr><td>行内选择器</td><td>1,0,0,0</td></tr><tr><td>!important</td><td>∞</td></tr></tbody></table><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230625234049636.png" alt="image-20230625234049636"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单地认识一下 JavaScript</title>
      <link href="/2023/07/07/javascript/"/>
      <url>/2023/07/07/javascript/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript"><a class="header-anchor" href="#JavaScript">¶</a>JavaScript</h1><hr><p>[TOC]</p><h3 id="1-1、引入JavaScript"><a class="header-anchor" href="#1-1、引入JavaScript">¶</a>1.1、引入JavaScript</h3><h4 id="1、内部标签"><a class="header-anchor" href="#1、内部标签">¶</a>1、内部标签</h4><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">'hello world!'</span>);<span class="comment">//</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><h4 id="2、外部标签"><a class="header-anchor" href="#2、外部标签">¶</a>2、外部标签</h4><p>假设有js文件 <code>abc.js</code></p><p>test.html⬇️</p><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"abc.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p>效果🐺<img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230504202624795.png" alt="image-20230504202624795"></p><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-CN"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"GBK"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--可以在这里引入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">'hello world!'</span>);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--可以在这里引入--&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="1-2、基本语法入门-ECMAScript"><a class="header-anchor" href="#1-2、基本语法入门-ECMAScript">¶</a>1.2、基本语法入门(ECMAScript)</h3><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">//JavaScript严格区分大小写</span></span><br><span class="line"><span class="comment">//1.定义变量变量类型变量名 = 变量值；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="title function_">alert</span>(num);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.条件控制</span></span><br><span class="line"><span class="keyword">if</span>(num&gt;<span class="number">1</span>){</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">"true"</span>);</span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>{</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">"1"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//console.log(...)在浏览器的控制台打印变量。 ==&gt;x'dang  System.out.print();</span></span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><h1 id="变量"><a class="header-anchor" href="#变量">¶</a>变量</h1><hr><h2 id="1-初入变量"><a class="header-anchor" href="#1-初入变量">¶</a>1.初入变量</h2><h3 id="1-1声明变量"><a class="header-anchor" href="#1-1声明变量">¶</a>1.1声明变量</h3><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age;</span><br></pre></td></tr></tbody></table></figure><h3 id="1-2赋值"><a class="header-anchor" href="#1-2赋值">¶</a>1.2赋值</h3><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">age = <span class="number">18</span>;</span><br></pre></td></tr></tbody></table></figure><h3 id="1-3输出结果"><a class="header-anchor" href="#1-3输出结果">¶</a>1.3输出结果</h3><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age);</span><br></pre></td></tr></tbody></table></figure><h3 id="1-4变量初始化"><a class="header-anchor" href="#1-4变量初始化">¶</a>1.4变量初始化</h3><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myname = <span class="string">'Jack'</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myname);</span><br></pre></td></tr></tbody></table></figure><h3 id="1-5-变量命名规范"><a class="header-anchor" href="#1-5-变量命名规范">¶</a>1.5 变量命名规范</h3><ul><li>由字母(A-Za-z、数字0-9)、下划)、美元符号($)组成，如：usrAge,num01,name</li><li>严格区分大小写。var app;和var App;是两个变量</li><li>不能以数字开头。18age 是错误的</li><li>不能是关键字、保留字，例如：var、for、while</li><li>变量名必须有意义。MMD BBD nl→age</li><li>遵守驼峰命名法。首字母小写，后面单词的首字母需要大写。myFirstName</li><li>推荐翻译网站：有道、爱词霸</li></ul><h2 id="2-变量的使用"><a class="header-anchor" href="#2-变量的使用">¶</a>2.变量的使用</h2><p>1.用户输入姓名</p><p><code>prompt("请输入")</code>⬇️</p><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myname = <span class="title function_">prompt</span>(<span class="string">'请输入'</span>);</span><br><span class="line"><span class="title function_">alert</span>(myname);</span><br></pre></td></tr></tbody></table></figure><h3 id="2-语法扩展"><a class="header-anchor" href="#2-语法扩展">¶</a>2.语法扩展</h3><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 1.更新变量</span></span><br><span class="line"><span class="keyword">var</span> myname = <span class="string">'LBW'</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myname);</span><br><span class="line">myname = <span class="string">'WC'</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myname);</span><br><span class="line"><span class="comment">// 2.声明多个变量</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">18</span>,</span><br><span class="line">    address = <span class="string">'赣州'</span>,</span><br><span class="line">    gz = <span class="number">2000</span>;</span><br><span class="line"><span class="comment">// 3.声明变量的特殊情况</span></span><br><span class="line"><span class="comment">// 3.1只声明不赋值，结果为 undefined</span></span><br><span class="line"><span class="keyword">var</span> sex;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sex);</span><br><span class="line"><span class="comment">// 3.2不声明 不赋值 直接使用某个变量会报错</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(tel);</span><br><span class="line"><span class="comment">// 3.3不声明 直接赋值 可以使用！！🤯</span></span><br><span class="line">qq = <span class="number">110</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(qq);</span><br></pre></td></tr></tbody></table></figure><h1 id="数据类型"><a class="header-anchor" href="#数据类型">¶</a>数据类型</h1><p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230629200203019-1688040127270-1.png" alt="image-20230629200203019"></p><h2 id="isNaN"><a class="header-anchor" href="#isNaN">¶</a>isNaN</h2><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// isNaN()这个方法用来判断非数字并且返回一个值 如果是数字返回的是 false 如果不是数字返回的同时是 true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="number">12</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="string">'JavaScript!!'</span>)); <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><h2 id="String"><a class="header-anchor" href="#String">¶</a>String</h2><p>字符串是由若干字符组成的，这些字符的数量就是字符串的长度。过字符神的length属性可以获取整个字符<br>串的长度。</p><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> strMsg = <span class="string">"只因你太美"</span>；</span><br><span class="line"><span class="title function_">alert</span>(strMsg.<span class="property">length</span>);<span class="comment">// 5</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C4D</title>
      <link href="/2023/06/26/cinema-4d/"/>
      <url>/2023/06/26/cinema-4d/</url>
      
        <content type="html"><![CDATA[<p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/20230810150308.png" alt=""></p><h1 id="1-1-场景的编辑"><a class="header-anchor" href="#1-1-场景的编辑">¶</a>1.1 场景的编辑</h1><table><thead><tr><th>位移</th><th>旋转</th><th>缩放</th></tr></thead><tbody><tr><td>Alt + 鼠标中键</td><td>Alt + 鼠标左键</td><td>滚动鼠标中键</td></tr></tbody></table><h2 id="1-2-对象的编辑"><a class="header-anchor" href="#1-2-对象的编辑">¶</a>1.2 对象的编辑</h2><table><thead><tr><th>位移</th><th>旋转</th><th>缩放</th></tr></thead><tbody><tr><td>e</td><td>t</td><td>r</td></tr></tbody></table><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230709205743192.png" alt="image-20230709205743192" style="zoom:200%;"><p>点击鼠标中间，可打开分视图</p><h2 id="1-3-可编辑对象"><a class="header-anchor" href="#1-3-可编辑对象">¶</a>1.3 可编辑对象</h2><p>可以用点工具、线工具、面工具对对象的点、线、面进行编辑</p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230709211642477.png" alt="image-20230709211642477" style="zoom:200%;"><h1 id="2-沙发椅案例"><a class="header-anchor" href="#2-沙发椅案例">¶</a>2. 沙发椅案例</h1><p>利用钢笔工具绘制样条线</p><p>利用==挤压==工具，将样条线生成体积（v.26 挤压在细分曲线里），点击挤压的同时按住Alt键，即可快速形成父子关系</p><img src="https://pic-img-picgo.oss-cn-nanjing.aliyuncs.com/picture/image-20230710235217672.png" alt="image-20230710235217672" style="zoom:200%;"><p><code>细分曲线</code>----让表面变得更加的光滑(容易平滑过度)</p><p>⭐凡是绿色图标的功能,都要使用时要按住Alt键,快速生成父子级</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
